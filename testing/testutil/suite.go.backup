package testutil

import (
	"cgl/api"
	"context"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"sync"
	"time"

	"github.com/stretchr/testify/suite"
)

// testLock ensures only one test suite runs at a time
var testLock sync.Mutex

// findAvailablePort finds an available TCP port
func findAvailablePort() (int, error) {
	listener, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		return 0, err
	}
	defer listener.Close()
	return listener.Addr().(*net.TCPAddr).Port, nil
}

// BaseSuite provides test environment management for test suites
// Embed this in your specific test suites to get automatic setup/teardown
type BaseSuite struct {
	suite.Suite
	SuiteName     string
	backendCancel context.CancelFunc
}

// SetupSuite runs once before all tests in the suite
// Starts Postgres in Docker and backend with 'go run'
func (s *BaseSuite) SetupSuite() {
	// Lock to prevent parallel suite execution
	testLock.Lock()

	if s.SuiteName == "" {
		s.SuiteName = "Test Suite"
	}

	fmt.Printf("\nüöÄ [%s] Starting test environment...\n", s.SuiteName)

	// Check if Postgres is already running
	checkCmd := exec.Command("docker", "ps", "-q", "-f", "name=chatgamelab-db-test")
	output, _ := checkCmd.Output()

	if len(output) > 0 {
		// Postgres is running, just drop all tables for clean state
		fmt.Printf("‚ôªÔ∏è  [%s] Postgres already running, cleaning database...\n", s.SuiteName)
		s.dropAllTables()
	} else {
		// Remove any stopped container with same name
		exec.Command("docker", "rm", "-f", "chatgamelab-db-test").Run()

		// Start Postgres with docker run
		fmt.Printf("üêò [%s] Starting Postgres...\n", s.SuiteName)
		cmd := exec.Command("docker", "run", "-d",
			"--name", "chatgamelab-db-test",
			"-e", "POSTGRES_DB=chatgamelab",
			"-e", "POSTGRES_USER=chatgamelab",
			"-e", "POSTGRES_PASSWORD=testpassword",
			"-p", "7104:5432",
			"postgres:18")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			s.TearDownSuite()
			s.T().Fatalf("Failed to start Postgres: %v", err)
		}
		// Wait for Postgres to be ready
		time.Sleep(3 * time.Second)
	}

	// Start backend in-process AFTER database is cleaned
	// This ensures backend detects empty DB and initializes schema
	fmt.Printf("üöÄ [%s] Starting backend in-process...\n", s.SuiteName)

	// Set environment variables for backend
	os.Setenv("DB_HOST", "localhost")
	os.Setenv("DB_USER", "chatgamelab")
	os.Setenv("DB_PASSWORD", "testpassword")
	os.Setenv("DB_DATABASE", "chatgamelab")
	os.Setenv("PORT_BACKEND", "7102")
	os.Setenv("PORT_POSTGRES", "7104")
	os.Setenv("DEV_MODE", "true")
	os.Setenv("DEV_JWT_SECRET", "testsecret123")
	os.Setenv("AUTH0_DOMAIN", "test.auth0.domain")
	os.Setenv("AUTH0_AUDIENCE", "test.auth0.audience")
	os.Setenv("PUBLIC_URL", "http://localhost:7102")

	// Create context for backend lifecycle
	ctx, cancel := context.WithCancel(context.Background())
	s.backendCancel = cancel

	// Start backend in goroutine
	go func() {
		api.RunServer(ctx, 7102, true) // port 7102, devMode true
	}()

	// Wait for backend to signal it's ready (DB initialized)
	fmt.Printf("‚è≥ [%s] Waiting for backend to initialize...\n", s.SuiteName)
	select {
	case <-api.ServerReady:
		fmt.Printf("‚úÖ [%s] Backend initialized, waiting for HTTP server...\n", s.SuiteName)
	case <-time.After(30 * time.Second):
		s.TearDownSuite()
		s.T().Fatalf("Backend initialization timed out")
	}

	// Now wait for HTTP server to be responsive
	if err := s.waitForBackend(10); err != nil {
		s.TearDownSuite()
		s.T().Fatalf("Backend HTTP server not ready: %v", err)
	}
	fmt.Printf("‚úÖ [%s] Backend fully ready!\n\n", s.SuiteName)
}

// TearDownSuite runs once after all tests in the suite
func (s *BaseSuite) TearDownSuite() {
	defer testLock.Unlock()

	fmt.Printf("\nüßπ [%s] Cleaning up test environment...\n", s.SuiteName)

	// Stop backend only (keep Postgres running for next suite)
	if s.backendCancel != nil {
		s.backendCancel()
		time.Sleep(100 * time.Millisecond) // Give backend time to shutdown
	}

	// Note: Postgres stays running for faster next suite startup
	fmt.Printf("‚úÖ [%s] Cleanup complete (Postgres kept running)\n\n", s.SuiteName)
}

// CreateUser creates a user with optional name and email (delegates to testutil.CreateUser)
// Example: user := s.CreateUser() or admin := s.CreateUser("alice", "alice@example.com").Role("admin")
func (s *BaseSuite) CreateUser(nameAndEmail ...string) *UserClient {
	return CreateUser(s.T(), nameAndEmail...)
}

// Public returns a public (unauthenticated) client (delegates to testutil.Public)
func (s *BaseSuite) Public() *PublicClient {
	return Public(s.T())
}

// dropAllTables drops all tables in the test database for a clean state
func (s *BaseSuite) dropAllTables() {
	// Use psql to drop all tables
	cmd := exec.Command("docker", "exec", "chatgamelab-db-test",
		"psql", "-U", "chatgamelab", "-d", "chatgamelab", "-c",
		"DROP SCHEMA public CASCADE; CREATE SCHEMA public; GRANT ALL ON SCHEMA public TO chatgamelab;")
	if err := cmd.Run(); err != nil {
		// If drop fails, fall back to restarting container
		fmt.Printf("‚ö†Ô∏è  Failed to drop tables, restarting Postgres...\n")
		exec.Command("docker", "rm", "-f", "chatgamelab-db-test").Run()
		restartCmd := exec.Command("docker", "run", "-d",
			"--name", "chatgamelab-db-test",
			"-e", "POSTGRES_DB=chatgamelab",
			"-e", "POSTGRES_USER=chatgamelab",
			"-e", "POSTGRES_PASSWORD=testpassword",
			"-p", "7104:5432",
			"postgres:18")
		restartCmd.Stdout = os.Stdout
		restartCmd.Stderr = os.Stderr
		restartCmd.Run()
		time.Sleep(3 * time.Second)
	}
}

// waitForBackend waits for the backend to be healthy
func (s *BaseSuite) waitForBackend(maxRetries int) error {
	client := &http.Client{Timeout: 2 * time.Second}
	healthURL := fmt.Sprintf("http://localhost:%d/api/status", s.backendPort)

	for i := 0; i < maxRetries; i++ {
		resp, err := client.Get(healthURL)
		if err == nil && resp.StatusCode == http.StatusOK {
			resp.Body.Close()
			return nil
		}
		if resp != nil {
			resp.Body.Close()
		}
		time.Sleep(time.Second)
	}

	return fmt.Errorf("backend not ready after %d retries", maxRetries)
}
