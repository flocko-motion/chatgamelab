---
trigger: model_decision
description: Apply when adding/modifying user-facing text, language switching, or translation-related functionality
---
# Internationalization (i18n) System Rules

## Overview

Our i18n system uses react-i18next with a hybrid approach: static translations for English/German and dynamic backend loading for arbitrary languages. This provides both performance and scalability.

## Architecture

### Core Components

- **Static Languages**: English (`en`) and German (`de`) are bundled as JSON files
- **Backend Loading**: Other languages are fetched on-demand via TanStack Query
- **Type Safety**: All translation keys are typed through `TranslationKey`
- **Centralized Config**: All language constants live in `src/i18n/config.ts`

### File Structure

```
src/i18n/
├── config.ts          # Central constants and helpers
├── types.ts           # TypeScript interfaces
├── resources.ts       # Static resource imports
├── backendLoader.ts   # Custom backend for dynamic loading
├── index.ts          # i18next initialization
└── locales/
    ├── en.json       # English translations
    └── de.json       # German translations
```

## Usage Rules

### 1. Language Detection

```typescript
import { isStaticLanguage, STATIC_LANGUAGES } from "@/i18n/config";

// Correct: Use helper function
if (isStaticLanguage(language)) {
  // Handle static language
}

// Wrong: Hardcoded checks
if (language === "en" || language === "de") {
  // Bad practice
}
```

### 2. Translation Keys

```typescript
// Correct: Use typed keys
const key: TranslationKey = "common:buttons.save";

// Wrong: String literals without typing
const key = "common:buttons.save";
```

### 3. Adding New Translations

#### For Static Languages (en/de)

1. Add keys to both `src/i18n/locales/en.json` and `src/i18n/locales/de.json`
2. Update `src/i18n/types.ts` if adding new namespaces
3. Update `NAMESPACES` in `src/i18n/config.ts` if adding new namespaces

#### Translation File Format

```json
{
  "namespace": {
    "key": "Translation text",
    "nested": {
      "key": "Nested translation"
    }
  }
}
```

### 4. Using Translations in Components

#### Standard Usage (Static Languages)

```typescript
import { useTranslation } from 'react-i18next';

function MyComponent() {
  const { t } = useTranslation('namespace');
  return <button>{t('key')}</button>;
}
```

#### Backend Translation (Dynamic Languages)

```typescript
import { useBackendTranslation } from '@/common/hooks/useTranslation';

function MyComponent() {
  const { t, isLoading, isError } = useBackendTranslation('namespace');

  if (isLoading) return <Loader />;
  if (isError) return <ErrorMessage />;

  return <button>{t('key')}</button>;
}
```

### 5. Language Switching

```typescript
import { useLanguageSwitcher } from "@/common/hooks/useTranslation";
import { LanguageSwitcher } from "@/common/components/LanguageSwitcher";

// Correct: Use the provided hook and component
const { availableLanguages, changeLanguage } = useLanguageSwitcher();
```

## Development Guidelines

### 1. Adding New Static Languages

1. Add language code to `STATIC_LANGUAGES` in `src/i18n/config.ts`
2. Create `src/i18n/locales/{lang}.json` with translations
3. Import and export in `src/i18n/resources.ts`
4. Update `isStaticLanguage` type inference will work automatically

### 2. Backend Integration

The current backend loader simulates API calls. To integrate with real backend:

1. Update `backendLoader.read()` in `src/i18n/backendLoader.ts`
2. Replace simulated delay with actual API calls
3. Maintain the same return signature for compatibility

### 3. Namespace Organization

- **common**: Shared UI elements (buttons, labels, messages)
- **navigation**: Navigation and routing
- **game**: Game-specific content
- **errors**: Error messages and validation

Keep namespaces focused and avoid mixing concerns.

### 4. Translation Best Practices

- Use descriptive keys: `user.profile.save` instead of `save1`
- Group related translations: `user.profile.*`, `user.settings.*`
- Avoid concatenating translation strings
- Use interpolation for dynamic values: `t('welcome', { name })`

## Performance Considerations

### Static Languages

- Bundled with the application
- No network requests
- Instant loading

### Dynamic Languages

- Loaded on-demand via TanStack Query
- Cached after first load
- Show loading states during fetch

## Testing Guidelines

### Unit Tests

```typescript
// Test translation key existence
expect(t("common:buttons.save")).toBeDefined();

// Test language switching
const { changeLanguage } = renderHook(() => useLanguageSwitcher());
act(() => changeLanguage("de"));
```

### Integration Tests

- Test language switching flow
- Verify backend loading states
- Test fallback behavior

## Common Pitfalls

### Don't

- Hardcode language checks instead of using `isStaticLanguage`
- Mix static and dynamic translation approaches in same component
- Forget to update both en.json and de.json for new keys
- Use string literals for translation keys without typing

### Do

- Always use `isStaticLanguage()` helper
- Use appropriate hooks (`useTranslation` vs `useBackendTranslation`)
- Keep translation files in sync
- Maintain type safety with `TranslationKey`

## Migration Notes

When migrating existing code:

1. Replace hardcoded strings with translation keys
2. Add corresponding translations to en.json and de.json
3. Use appropriate translation hook based on language needs
4. Test language switching functionality

## Future Enhancements

Planned improvements:

- Real backend API integration
- Translation management interface
- Automated translation key validation
- Pluralization and formatting rules
