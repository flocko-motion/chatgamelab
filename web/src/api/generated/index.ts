/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export enum ObjRole {
  RoleAdmin = "admin",
  RoleHead = "head",
  RoleStaff = "staff",
  RoleParticipant = "participant",
}

export enum ObjInviteStatus {
  InviteStatusPending = "pending",
  InviteStatusAccepted = "accepted",
  InviteStatusDeclined = "declined",
  InviteStatusExpired = "expired",
  InviteStatusRevoked = "revoked",
}

export interface DbUserSessionWithGame {
  aiModel?: string;
  /** AI model used for playing. */
  aiPlatform?: string;
  /** JSON with arbitrary details to be used within that model and within that session. */
  aiSession?: string;
  apiKey?: ObjApiKey;
  /** API key used to pay for this session (sponsored or user-owned), implicitly defines platform. */
  apiKeyId?: string;
  gameDescription?: string;
  gameId?: string;
  gameName?: string;
  id?: string;
  imageStyle?: string;
  /** Set to true when image generation fails due to organization verification required */
  isOrganisationUnverified?: boolean;
  meta?: ObjMeta;
  /** Defines the status fields available in the game; copied from game.status_fields at launch. */
  statusFields?: string;
  /** AI-generated visual theme for the game player UI (JSON) */
  theme?: ObjGameTheme;
  userId?: string;
  userName?: string;
  workshopId?: string;
}

export interface HttpxErrorResponse {
  /** Machine-readable error code */
  code?: string;
  /** Human-readable error message */
  message?: string;
  /** Deprecated: use Code instead */
  type?: string;
}

export interface ObjAiModel {
  description?: string;
  /** technical name without spaces, e.g. "gpt-4-nano" */
  id?: string;
  /** display name e.g. "GPT 4 Nano" */
  name?: string;
}

export interface ObjAiPlatform {
  /** technical name without spaces, e.g. "openai" */
  id?: string;
  models?: ObjAiModel[];
  /** display name e.g. "OpenAI" */
  name?: string;
  /** whether this platform supports user API keys */
  supportsApiKey?: boolean;
}

export interface ObjApiKey {
  id?: string;
  keyShortened?: string;
  meta?: ObjMeta;
  name?: string;
  platform?: string;
  userId?: string;
  userName?: string;
}

export interface ObjApiKeyShare {
  allowPublicSponsoredPlays?: boolean;
  apiKey?: ObjApiKey;
  apiKeyId?: string;
  id?: string;
  institution?: ObjInstitution;
  isUserDefault?: boolean;
  meta?: ObjMeta;
  user?: ObjUser;
  workshop?: ObjWorkshop;
}

export interface ObjGame {
  cloneCount?: number;
  /** Creator info (populated when fetching games) */
  creatorId?: string;
  creatorName?: string;
  /**
   * Additional CSS for the game, probably generated by the LLM.
   * Should be validated/parsed strictly to avoid arbitrary code execution.
   */
  css?: string;
  description?: string;
  firstImage?: number[];
  /**
   * Quick start: pre-generated first scene of the game.
   * This is generated content (first output after the system message) and may be
   * regenerated from time to time to avoid being too static.
   */
  firstMessage?: string;
  firstStatus?: string;
  icon?: number[];
  id?: string;
  /** What style should the images have? */
  imageStyle?: string;
  meta?: ObjMeta;
  name?: string;
  /** Original creator info (populated when fetching games, if originally cloned) */
  originalCreatorId?: string;
  originalCreatorName?: string;
  /** Tracking: original creator (for cloned games) and usage statistics */
  originallyCreatedBy?: string;
  playCount?: number;
  /**
   * Private share links contain secret random tokens to limit access to the game.
   * They are sponsored, so invited players don't require their own API key.
   */
  privateShareHash?: string;
  privateSponsoredApiKeyId?: string;
  /** Access rights and payments. public = true: discoverable on the website and playable by anyone. */
  public?: boolean;
  /** If public, a sponsored API key can be provided to pay for any public plays. */
  publicSponsoredApiKeyId?: string;
  /** The status fields available to the LLM, shaping the JSON format for status. */
  statusFields?: string;
  /** How should the game start? First scene? How is the player welcomed? */
  systemMessageGameStart?: string;
  /**
   * Game details and system messages for the LLM.
   * What is the game about? How does it work? Player role? World description?
   */
  systemMessageScenario?: string;
  tags?: ObjGameTag[];
  /** Optional workshop scope (games can be created within a workshop context) */
  workshopId?: string;
}

export interface ObjGameSession {
  aiModel?: string;
  /** AI model used for playing. */
  aiPlatform?: string;
  /** JSON with arbitrary details to be used within that model and within that session. */
  aiSession?: string;
  apiKey?: ObjApiKey;
  /** API key used to pay for this session (sponsored or user-owned), implicitly defines platform. */
  apiKeyId?: string;
  gameDescription?: string;
  gameId?: string;
  gameName?: string;
  id?: string;
  imageStyle?: string;
  /** Set to true when image generation fails due to organization verification required */
  isOrganisationUnverified?: boolean;
  meta?: ObjMeta;
  /** Defines the status fields available in the game; copied from game.status_fields at launch. */
  statusFields?: string;
  /** AI-generated visual theme for the game player UI (JSON) */
  theme?: ObjGameTheme;
  userId?: string;
  userName?: string;
  workshopId?: string;
}

export interface ObjGameSessionMessage {
  gameSessionId?: string;
  id?: string;
  image?: number[];
  imagePrompt?: string;
  /** Plain text of the scene (system message, player action, or game response). */
  message?: string;
  meta?: ObjMeta;
  /** Sequence number within the session, starting at 1 */
  seq?: number;
  /** JSON encoded status fields. */
  statusFields?: ObjStatusField[];
  stream?: boolean;
  /** player: user message; game: LLM/game response; system: initial system/context messages. */
  type?: string;
}

export interface ObjGameTag {
  gameId?: string;
  id?: string;
  meta?: ObjMeta;
  tag?: string;
}

export interface ObjGameTheme {
  /** fields that override the preset defaults */
  override?: ObjGameThemeOverride;
  /** preset name (e.g., "space", "fantasy") or "custom" */
  preset?: string;
}

export interface ObjGameThemeBackground {
  /** none, stars, bubbles, fireflies, snow, rain, matrix */
  animation?: string;
  /** warm, cool, neutral, dark, black */
  tint?: string;
}

export interface ObjGameThemeCards {
  /** none, thin, medium, thick */
  borderThickness?: string;
}

export interface ObjGameThemeCorners {
  /** amber, emerald, cyan, violet, rose, slate */
  color?: string;
  /** brackets, flourish, arrows, dots, none */
  style?: string;
}

export interface ObjGameThemeDivider {
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  color?: string;
  /** dot, dots, line, diamond, star, dash, none */
  style?: string;
}

export interface ObjGameThemeGameMessage {
  /** white, creme, dark, black, blue, blueLight, green, greenLight, red, redLight, amber, amberLight, violet, violetLight, rose, roseLight, cyan, cyanLight */
  bgColor?: string;
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  borderColor?: string;
  dropCap?: boolean;
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  dropCapColor?: string;
  /** dark, light, hacker, terminal */
  fontColor?: string;
}

export interface ObjGameThemeHeader {
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  accentColor?: string;
  /** white, creme, dark, black, blue, blueLight, green, greenLight, red, redLight, amber, amberLight, violet, violetLight, rose, roseLight, cyan, cyanLight */
  bgColor?: string;
  /** dark, light, hacker, terminal */
  fontColor?: string;
}

export interface ObjGameThemeOverride {
  background?: ObjGameThemeBackground;
  cards?: ObjGameThemeCards;
  corners?: ObjGameThemeCorners;
  divider?: ObjGameThemeDivider;
  gameMessage?: ObjGameThemeGameMessage;
  header?: ObjGameThemeHeader;
  player?: ObjGameThemePlayer;
  statusEmojis?: Record<string, string>;
  statusFields?: ObjGameThemeStatusFields;
  thinking?: ObjGameThemeThinking;
  typography?: ObjGameThemeTypography;
}

export interface ObjGameThemePlayer {
  /** white, creme, dark, black, blue, blueLight, green, greenLight, red, redLight, amber, amberLight, violet, violetLight, rose, roseLight, cyan, cyanLight */
  bgColor?: string;
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  borderColor?: string;
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  color?: string;
  /** dark, light, hacker, terminal */
  fontColor?: string;
  /** dot, arrow, chevron, diamond, cursor, underscore, pipe, none */
  indicator?: string;
  indicatorBlink?: boolean;
}

export interface ObjGameThemeStatusFields {
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  accentColor?: string;
  /** white, creme, dark, black, blue, blueLight, green, greenLight, red, redLight, amber, amberLight, violet, violetLight, rose, roseLight, cyan, cyanLight */
  bgColor?: string;
  /** amber, emerald, cyan, violet, rose, slate, hacker, terminal, brown, pink, orange */
  borderColor?: string;
  /** dark, light, hacker, terminal */
  fontColor?: string;
}

export interface ObjGameThemeThinking {
  /** dots, block, pipe, underscore, none */
  streamingCursor?: string;
  /** dots, spinner, pulse, typewriter */
  style?: string;
  /** e.g. "The story unfolds..." */
  text?: string;
}

export interface ObjGameThemeTypography {
  /** serif, sans, mono, fantasy */
  messages?: string;
}

export interface ObjInstitution {
  id?: string;
  members?: ObjInstitutionMember[];
  meta?: ObjMeta;
  name?: string;
}

export interface ObjInstitutionMember {
  email?: string;
  name?: string;
  role?: ObjRole;
  userId?: string;
}

export interface ObjMeta {
  createdAt?: string;
  createdBy?: UuidNullUUID;
  modifiedAt?: string;
  modifiedBy?: UuidNullUUID;
}

export interface ObjStatusField {
  name?: string;
  value?: string;
}

export interface ObjSystemSettings {
  createdAt?: string;
  defaultAiModel?: string;
  id?: string;
  modifiedAt?: string;
}

export interface ObjUser {
  auth0Id?: string;
  deletedAt?: string;
  email?: string;
  id?: string;
  meta?: ObjMeta;
  name?: string;
  role?: ObjUserRole;
  showAiModelSelector?: boolean;
}

export interface ObjUserRole {
  id?: string;
  institution?: ObjInstitution;
  meta?: ObjMeta;
  role?: ObjRole;
  userId?: string;
  workshop?: ObjWorkshop;
}

export interface ObjUserRoleInvite {
  acceptedAt?: string;
  acceptedBy?: string;
  expiresAt?: string;
  id?: string;
  institutionId?: string;
  inviteToken?: string;
  invitedEmail?: string;
  invitedUserId?: string;
  maxUses?: number;
  meta?: ObjMeta;
  role?: ObjRole;
  status?: ObjInviteStatus;
  usesCount?: number;
  workshopId?: string;
}

export interface ObjUserStats {
  gamesCreated?: number;
  gamesPlayed?: number;
  messagesSent?: number;
  totalPlaysOnGames?: number;
}

export interface ObjWorkshop {
  active?: boolean;
  id?: string;
  institution?: ObjInstitution;
  invites?: ObjUserRoleInvite[];
  meta?: ObjMeta;
  name?: string;
  participants?: ObjWorkshopParticipant[];
  public?: boolean;
}

export interface ObjWorkshopParticipant {
  accessToken?: string;
  active?: boolean;
  id?: string;
  meta?: ObjMeta;
  name?: string;
  workshopId?: string;
}

export interface RoutesAcceptInviteResponse {
  authToken?: string;
  message?: string;
  user?: ObjUser;
}

export interface RoutesApiKeyInfoResponse {
  linkedShares?: ObjApiKeyShare[];
  share?: ObjApiKeyShare;
}

export interface RoutesCreateApiKeyRequest {
  key?: string;
  name?: string;
  platform?: string;
}

export interface RoutesCreateGameRequest {
  description?: string;
  name?: string;
  public?: boolean;
}

export interface RoutesCreateInstitutionInviteRequest {
  institutionId?: string;
  invitedEmail?: string;
  invitedUserId?: string;
  role?: string;
}

export interface RoutesCreateInstitutionRequest {
  name?: string;
}

export interface RoutesCreateSessionRequest {
  model?: string;
  shareId?: string;
}

export interface RoutesCreateWorkshopInviteRequest {
  expiresAt?: string;
  maxUses?: number;
  workshopId?: string;
}

export interface RoutesCreateWorkshopRequest {
  active?: boolean;
  institutionId?: string;
  name?: string;
  public?: boolean;
}

export interface RoutesImageStatusResponse {
  errorCode?: string;
  errorMsg?: string;
  exists?: boolean;
  hasError?: boolean;
  hash?: string;
  isComplete?: boolean;
  isOrganisationUnverified?: boolean;
}

export interface RoutesInviteResponse {
  createdAt?: string;
  expiresAt?: string;
  id?: string;
  institutionId?: string;
  inviteToken?: string;
  invitedEmail?: string;
  invitedUserId?: string;
  maxUses?: number;
  modifiedAt?: string;
  role?: string;
  status?: string;
  usesCount?: number;
  workshopId?: string;
}

export interface RoutesLanguage {
  iso?: string;
  label?: string;
}

export interface RoutesRegisterRequest {
  email?: string;
  name?: string;
}

export interface RoutesRolesResponse {
  roles?: ObjRole[];
}

export interface RoutesSessionActionRequest {
  message?: string;
  /** Current status to pass to AI */
  statusFields?: ObjStatusField[];
}

export interface RoutesSessionResponse {
  aiModel?: string;
  /** AI model used for playing. */
  aiPlatform?: string;
  /** JSON with arbitrary details to be used within that model and within that session. */
  aiSession?: string;
  apiKey?: ObjApiKey;
  /** API key used to pay for this session (sponsored or user-owned), implicitly defines platform. */
  apiKeyId?: string;
  gameDescription?: string;
  gameId?: string;
  gameName?: string;
  id?: string;
  imageStyle?: string;
  /** Set to true when image generation fails due to organization verification required */
  isOrganisationUnverified?: boolean;
  messages?: ObjGameSessionMessage[];
  meta?: ObjMeta;
  /** Defines the status fields available in the game; copied from game.status_fields at launch. */
  statusFields?: string;
  /** AI-generated visual theme for the game player UI (JSON) */
  theme?: ObjGameTheme;
  userId?: string;
  userName?: string;
  workshopId?: string;
}

export interface RoutesSetUserRoleRequest {
  institutionId?: string;
  role?: string;
  workshopId?: string;
}

export interface RoutesShareRequest {
  allowPublicSponsoredPlays?: boolean;
  institutionId?: string;
  userId?: string;
  workshopId?: string;
}

export interface RoutesStatusResponse {
  status?: string;
  uptime?: string;
}

export interface RoutesUpdateApiKeyRequest {
  name?: string;
}

export interface RoutesUpdateInstitutionRequest {
  name?: string;
}

export interface RoutesUpdateWorkshopRequest {
  active?: boolean;
  name?: string;
  public?: boolean;
}

export interface RoutesUserUpdateRequest {
  defaultApiKeyShareId?: string;
  email?: string;
  name?: string;
  showAiModelSelector?: boolean;
}

export interface RoutesUsersJwtResponse {
  auth0Id?: string;
  token?: string;
  userId?: string;
}

export interface RoutesUsersNewRequest {
  email?: string;
  name?: string;
}

export interface RoutesVersionResponse {
  buildTime?: string;
  gitCommit?: string;
  version?: string;
}

export interface UuidNullUUID {
  uuid?: string;
  /** Valid is true if UUID is not NULL */
  valid?: boolean;
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  JsonApi = "application/vnd.api+json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "http://localhost:8080/api";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key],
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key),
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.JsonApi]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) => {
      if (input instanceof FormData) {
        return input;
      }

      return Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
              ? JSON.stringify(property)
              : `${property}`,
        );
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams,
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken,
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          ...(type && type !== ContentType.FormData
            ? { "Content-Type": type }
            : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      },
    ).then(async (response) => {
      const r = response as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat
        ? r
        : await responseToParse[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title ChatGameLab API
 * @version 1.0
 * @license MIT
 * @baseUrl http://localhost:8080/api
 * @contact ChatGameLab Team (https://chatgamelab.com)
 *
 * API for ChatGameLab - an AI-powered interactive game platform
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  apikeys = {
    /**
     * @description Returns all API key shares accessible to the current user
     *
     * @tags apikeys
     * @name ApikeysList
     * @summary List API keys
     * @request GET:/apikeys
     * @secure
     */
    apikeysList: (params: RequestParams = {}) =>
      this.request<ObjApiKeyShare[], HttpxErrorResponse>({
        path: `/apikeys`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new API key with automatic self-share
     *
     * @tags apikeys
     * @name PostApikeys
     * @summary Create API key
     * @request POST:/apikeys/new
     * @secure
     */
    postApikeys: (
      request: RoutesCreateApiKeyRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjApiKeyShare, HttpxErrorResponse>({
        path: `/apikeys/new`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns share info and linked shares for an API key share
     *
     * @tags apikeys
     * @name ApikeysDetail
     * @summary Get API key info
     * @request GET:/apikeys/{id}
     * @secure
     */
    apikeysDetail: (id: string, params: RequestParams = {}) =>
      this.request<RoutesApiKeyInfoResponse, HttpxErrorResponse>({
        path: `/apikeys/${id}`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description If ?cascade=true, deletes key and all shares; otherwise unshares (deletes single share)
     *
     * @tags apikeys
     * @name ApikeysDelete
     * @summary Delete or unshare API key
     * @request DELETE:/apikeys/{id}
     * @secure
     */
    apikeysDelete: (
      id: string,
      query?: {
        /** Delete key and all shares */
        cascade?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<ObjApiKeyShare, HttpxErrorResponse>({
        path: `/apikeys/${id}`,
        method: "DELETE",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Updates API key name
     *
     * @tags apikeys
     * @name ApikeysPartialUpdate
     * @summary Update API key
     * @request PATCH:/apikeys/{id}
     * @secure
     */
    apikeysPartialUpdate: (
      id: string,
      request: RoutesUpdateApiKeyRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjApiKeyShare, HttpxErrorResponse>({
        path: `/apikeys/${id}`,
        method: "PATCH",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Shares an API key with a user, workshop, or institution
     *
     * @tags apikeys
     * @name SharesCreate
     * @summary Share API key
     * @request POST:/apikeys/{id}/shares
     * @secure
     */
    sharesCreate: (
      id: string,
      request: RoutesShareRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjApiKeyShare, HttpxErrorResponse>({
        path: `/apikeys/${id}/shares`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  auth = {
    /**
     * @description Checks if a username is available for registration
     *
     * @tags auth
     * @name CheckNameList
     * @summary Check if name is available
     * @request GET:/auth/check-name
     */
    checkNameList: (
      query: {
        /** Name to check */
        name: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<Record<string, boolean>, HttpxErrorResponse>({
        path: `/auth/check-name`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Registers a new user after Auth0 authentication. Requires valid Auth0 token.
     *
     * @tags auth
     * @name RegisterCreate
     * @summary Register new user
     * @request POST:/auth/register
     * @secure
     */
    registerCreate: (
      request: RoutesRegisterRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/auth/register`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
  games = {
    /**
     * @description Returns a list of games. If authenticated, includes user's private games.
     *
     * @tags games
     * @name GamesList
     * @summary List games
     * @request GET:/games
     */
    gamesList: (
      query?: {
        /** Search games by name (case-insensitive) */
        search?: string;
        /** Sort field (name, createdAt, modifiedAt) */
        sortBy?: string;
        /** Sort direction (asc, desc) */
        sortDir?: string;
        /** Filter type (all, own, public, organization, favorites) */
        filter?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<ObjGame[], HttpxErrorResponse>({
        path: `/games`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns the list of games the authenticated user has marked as favourites
     *
     * @tags games
     * @name FavouritesList
     * @summary Get user's favourite games
     * @request GET:/games/favourites
     * @secure
     */
    favouritesList: (params: RequestParams = {}) =>
      this.request<ObjGame[], HttpxErrorResponse>({
        path: `/games/favourites`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new game from JSON or YAML. Accepts either a simple name or full game object.
     *
     * @tags games
     * @name PostGames
     * @summary Create game
     * @request POST:/games/new
     * @secure
     */
    postGames: (request: RoutesCreateGameRequest, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/new`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns a single game by its ID
     *
     * @tags games
     * @name GamesDetail
     * @summary Get game by ID
     * @request GET:/games/{id}
     */
    gamesDetail: (id: string, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Updates a game's properties
     *
     * @tags games
     * @name GamesCreate
     * @summary Update game
     * @request POST:/games/{id}
     * @secure
     */
    gamesCreate: (id: string, game: ObjGame, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}`,
        method: "POST",
        body: game,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Deletes a game by ID
     *
     * @tags games
     * @name GamesDelete
     * @summary Delete game
     * @request DELETE:/games/{id}
     * @secure
     */
    gamesDelete: (id: string, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a copy of a game for the authenticated user
     *
     * @tags games
     * @name CloneCreate
     * @summary Clone game
     * @request POST:/games/{id}/clone
     * @secure
     */
    cloneCreate: (id: string, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}/clone`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Adds a game to the authenticated user's favourites
     *
     * @tags games
     * @name FavouriteCreate
     * @summary Add game to favourites
     * @request POST:/games/{id}/favourite
     * @secure
     */
    favouriteCreate: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, boolean>, HttpxErrorResponse>({
        path: `/games/${id}/favourite`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Removes a game from the authenticated user's favourites
     *
     * @tags games
     * @name FavouriteDelete
     * @summary Remove game from favourites
     * @request DELETE:/games/{id}/favourite
     * @secure
     */
    favouriteDelete: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, boolean>, HttpxErrorResponse>({
        path: `/games/${id}/favourite`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Lists sessions for a game
     *
     * @tags sessions
     * @name SessionsList
     * @summary List game sessions
     * @request GET:/games/{id}/sessions
     * @secure
     */
    sessionsList: (id: string, params: RequestParams = {}) =>
      this.request<ObjGameSession[], HttpxErrorResponse>({
        path: `/games/${id}/sessions`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new session for a game and returns the session with first message
     *
     * @tags sessions
     * @name SessionsCreate
     * @summary Create game session
     * @request POST:/games/{id}/sessions
     * @secure
     */
    sessionsCreate: (
      id: string,
      request: RoutesCreateSessionRequest,
      params: RequestParams = {},
    ) =>
      this.request<RoutesSessionResponse, HttpxErrorResponse>({
        path: `/games/${id}/sessions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Exports a game's configuration as YAML format
     *
     * @tags games
     * @name YamlList
     * @summary Export game as YAML
     * @request GET:/games/{id}/yaml
     * @secure
     */
    yamlList: (id: string, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}/yaml`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Updates a game's configuration from YAML format
     *
     * @tags games
     * @name YamlUpdate
     * @summary Import game from YAML
     * @request PUT:/games/{id}/yaml
     * @secure
     */
    yamlUpdate: (id: string, yaml: string, params: RequestParams = {}) =>
      this.request<ObjGame, HttpxErrorResponse>({
        path: `/games/${id}/yaml`,
        method: "PUT",
        body: yaml,
        secure: true,
        format: "json",
        ...params,
      }),
  };
  institutions = {
    /**
     * @description Lists all institutions
     *
     * @tags institutions
     * @name InstitutionsList
     * @summary List institutions
     * @request GET:/institutions
     * @secure
     */
    institutionsList: (params: RequestParams = {}) =>
      this.request<ObjInstitution[], HttpxErrorResponse>({
        path: `/institutions`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new institution
     *
     * @tags institutions
     * @name InstitutionsCreate
     * @summary Create institution
     * @request POST:/institutions
     * @secure
     */
    institutionsCreate: (
      request: RoutesCreateInstitutionRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjInstitution, HttpxErrorResponse>({
        path: `/institutions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Gets an institution by ID
     *
     * @tags institutions
     * @name InstitutionsDetail
     * @summary Get institution
     * @request GET:/institutions/{id}
     * @secure
     */
    institutionsDetail: (id: string, params: RequestParams = {}) =>
      this.request<ObjInstitution, HttpxErrorResponse>({
        path: `/institutions/${id}`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Soft-deletes an institution (admin only)
     *
     * @tags institutions
     * @name InstitutionsDelete
     * @summary Delete institution
     * @request DELETE:/institutions/{id}
     * @secure
     */
    institutionsDelete: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/institutions/${id}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Updates an institution
     *
     * @tags institutions
     * @name InstitutionsPartialUpdate
     * @summary Update institution
     * @request PATCH:/institutions/{id}
     * @secure
     */
    institutionsPartialUpdate: (
      id: string,
      request: RoutesUpdateInstitutionRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjInstitution, HttpxErrorResponse>({
        path: `/institutions/${id}`,
        method: "PATCH",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns all members of an institution
     *
     * @tags institutions
     * @name MembersList
     * @summary Get institution members
     * @request GET:/institutions/{id}/members
     * @secure
     */
    membersList: (id: string, params: RequestParams = {}) =>
      this.request<ObjUser[], HttpxErrorResponse>({
        path: `/institutions/${id}/members`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Removes a member from an institution (head or admin only)
     *
     * @tags institutions
     * @name MembersDelete
     * @summary Remove member from institution
     * @request DELETE:/institutions/{id}/members/{userID}
     * @secure
     */
    membersDelete: (id: string, userId: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/institutions/${id}/members/${userId}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  invites = {
    /**
     * @description Lists invites scoped by user permissions. Admins see all invites, regular users see only their own pending invites.
     *
     * @tags invites
     * @name InvitesList
     * @summary List invites
     * @request GET:/invites
     * @secure
     */
    invitesList: (params: RequestParams = {}) =>
      this.request<RoutesInviteResponse[], HttpxErrorResponse>({
        path: `/invites`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a targeted invite for a user to join an institution as head or staff
     *
     * @tags invites
     * @name InstitutionCreate
     * @summary Create institution invite
     * @request POST:/invites/institution
     * @secure
     */
    institutionCreate: (
      request: RoutesCreateInstitutionInviteRequest,
      params: RequestParams = {},
    ) =>
      this.request<RoutesInviteResponse, HttpxErrorResponse>({
        path: `/invites/institution`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates an open invite for users to join a workshop as participants
     *
     * @tags invites
     * @name WorkshopCreate
     * @summary Create workshop invite
     * @request POST:/invites/workshop
     * @secure
     */
    workshopCreate: (
      request: RoutesCreateWorkshopInviteRequest,
      params: RequestParams = {},
    ) =>
      this.request<RoutesInviteResponse, HttpxErrorResponse>({
        path: `/invites/workshop`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Retrieves a specific invite. Auto-detects whether parameter is a UUID (ID) or string (token). Admins can see any invite, regular users can only see invites targeted to them or created by them.
     *
     * @tags invites
     * @name InvitesDetail
     * @summary Get invite by ID or token
     * @request GET:/invites/{idOrToken}
     * @secure
     */
    invitesDetail: (idOrToken: string, params: RequestParams = {}) =>
      this.request<ObjUserRoleInvite, HttpxErrorResponse>({
        path: `/invites/${idOrToken}`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Accepts an invite by ID or token. For workshop invites, can be used anonymously (creates ad-hoc user). For institution invites, requires authentication.
     *
     * @tags invites
     * @name AcceptCreate
     * @summary Accept invite
     * @request POST:/invites/{idOrToken}/accept
     * @secure
     */
    acceptCreate: (idOrToken: string, params: RequestParams = {}) =>
      this.request<RoutesAcceptInviteResponse, HttpxErrorResponse>({
        path: `/invites/${idOrToken}/accept`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Revokes a pending invite (creator, admin, or institution staff for workshop invites)
     *
     * @tags invites
     * @name InvitesDelete
     * @summary Revoke invite
     * @request DELETE:/invites/{id}
     * @secure
     */
    invitesDelete: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/invites/${id}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Declines an invite by ID
     *
     * @tags invites
     * @name DeclineCreate
     * @summary Decline invite
     * @request POST:/invites/{id}/decline
     * @secure
     */
    declineCreate: (id: string, params: RequestParams = {}) =>
      this.request<ObjUserRoleInvite, HttpxErrorResponse>({
        path: `/invites/${id}/decline`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Re-activates a revoked invite (creator, admin, or institution staff for workshop invites)
     *
     * @tags invites
     * @name ReactivateCreate
     * @summary Reactivate invite
     * @request POST:/invites/{id}/reactivate
     * @secure
     */
    reactivateCreate: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/invites/${id}/reactivate`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  languages = {
    /**
     * @description Returns a list of available languages for the application
     *
     * @tags languages
     * @name LanguagesList
     * @summary Get available languages
     * @request GET:/languages
     */
    languagesList: (params: RequestParams = {}) =>
      this.request<RoutesLanguage[], any>({
        path: `/languages`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Returns the translation JSON file for the specified language code
     *
     * @tags languages
     * @name LanguagesDetail
     * @summary Get locale file for a specific language
     * @request GET:/languages/{code}
     */
    languagesDetail: (code: string, params: RequestParams = {}) =>
      this.request<Record<string, any>, Record<string, string>>({
        path: `/languages/${code}`,
        method: "GET",
        format: "json",
        ...params,
      }),
  };
  messages = {
    /**
     * @description Returns the generated image for a game session message. Checks in-memory cache first (for partial/WIP images), then database. No authentication required - message UUIDs are random and unguessable.
     *
     * @tags messages
     * @name ImageList
     * @summary Get message image
     * @request GET:/messages/{id}/image
     */
    imageList: (id: string, params: RequestParams = {}) =>
      this.request<File, HttpxErrorResponse>({
        path: `/messages/${id}/image`,
        method: "GET",
        format: "blob",
        ...params,
      }),

    /**
     * @description Returns the current hash and completion status of an image being generated. Frontend can poll this to detect when new partial/final images are available.
     *
     * @tags messages
     * @name ImageStatusList
     * @summary Get image generation status
     * @request GET:/messages/{id}/image/status
     */
    imageStatusList: (id: string, params: RequestParams = {}) =>
      this.request<RoutesImageStatusResponse, HttpxErrorResponse>({
        path: `/messages/${id}/image/status`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Server-Sent Events endpoint for streaming message chunks.
     *
     * @tags messages
     * @name StreamList
     * @summary Stream message updates (SSE)
     * @request GET:/messages/{id}/stream
     */
    streamList: (id: string, params: RequestParams = {}) =>
      this.request<string, string>({
        path: `/messages/${id}/stream`,
        method: "GET",
        ...params,
      }),
  };
  platforms = {
    /**
     * @description Returns all available AI platforms with their metadata
     *
     * @tags platforms
     * @name PlatformsList
     * @summary List AI platforms
     * @request GET:/platforms
     */
    platformsList: (params: RequestParams = {}) =>
      this.request<ObjAiPlatform[], HttpxErrorResponse>({
        path: `/platforms`,
        method: "GET",
        format: "json",
        ...params,
      }),
  };
  restart = {
    /**
     * @description Admin-only endpoint that triggers a server restart.
     *
     * @tags admin
     * @name RestartCreate
     * @summary Restart server
     * @request POST:/restart
     * @secure
     */
    restartCreate: (params: RequestParams = {}) =>
      this.request<string, HttpxErrorResponse>({
        path: `/restart`,
        method: "POST",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  roles = {
    /**
     * @description Returns all available user roles
     *
     * @tags roles
     * @name RolesList
     * @summary Get available roles
     * @request GET:/roles
     * @secure
     */
    rolesList: (params: RequestParams = {}) =>
      this.request<RoutesRolesResponse, HttpxErrorResponse>({
        path: `/roles`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  sessions = {
    /**
     * @description Returns recent sessions for the authenticated user with game names
     *
     * @tags sessions
     * @name SessionsList
     * @summary List user sessions
     * @request GET:/sessions
     * @secure
     */
    sessionsList: (
      query?: {
        /** Search by game name */
        search?: string;
        /** Sort field: game, model, lastPlayed (default) */
        sortBy?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<DbUserSessionWithGame[], HttpxErrorResponse>({
        path: `/sessions`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns session details. Optional query parameter can include latest message.
     *
     * @tags sessions
     * @name SessionsDetail
     * @summary Get session
     * @request GET:/sessions/{id}
     */
    sessionsDetail: (
      id: string,
      query?: {
        /** Message inclusion: none|latest|all */
        messages?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<RoutesSessionResponse, HttpxErrorResponse>({
        path: `/sessions/${id}`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Sends a player message/action to a session and returns the resulting message.
     *
     * @tags sessions
     * @name SessionsCreate
     * @summary Send session action
     * @request POST:/sessions/{id}
     */
    sessionsCreate: (
      id: string,
      request: RoutesSessionActionRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjGameSessionMessage, HttpxErrorResponse>({
        path: `/sessions/${id}`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Deletes a session and all its messages. User must be the owner.
     *
     * @tags sessions
     * @name SessionsDelete
     * @summary Delete session
     * @request DELETE:/sessions/{id}
     * @secure
     */
    sessionsDelete: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/sessions/${id}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  status = {
    /**
     * @description Returns the current server status and uptime
     *
     * @tags status
     * @name StatusList
     * @summary Get server status
     * @request GET:/status
     */
    statusList: (params: RequestParams = {}) =>
      this.request<RoutesStatusResponse, any>({
        path: `/status`,
        method: "GET",
        format: "json",
        ...params,
      }),
  };
  system = {
    /**
     * @description Returns the global system settings
     *
     * @tags system
     * @name SettingsList
     * @summary Get system settings
     * @request GET:/system/settings
     */
    settingsList: (params: RequestParams = {}) =>
      this.request<ObjSystemSettings, HttpxErrorResponse>({
        path: `/system/settings`,
        method: "GET",
        format: "json",
        ...params,
      }),
  };
  users = {
    /**
     * @description Returns all users
     *
     * @tags users
     * @name UsersList
     * @summary List users
     * @request GET:/users
     * @secure
     */
    usersList: (params: RequestParams = {}) =>
      this.request<ObjUser[], HttpxErrorResponse>({
        path: `/users`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns the currently authenticated user
     *
     * @tags users
     * @name GetUsers
     * @summary Get current user
     * @request GET:/users/me
     * @secure
     */
    getUsers: (params: RequestParams = {}) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/me`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns statistics for the authenticated user
     *
     * @tags users
     * @name MeStatsList
     * @summary Get current user statistics
     * @request GET:/users/me/stats
     * @secure
     */
    meStatsList: (params: RequestParams = {}) =>
      this.request<ObjUserStats, HttpxErrorResponse>({
        path: `/users/me/stats`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new user without Auth0. Only available in dev mode.
     *
     * @tags users
     * @name PostUsers
     * @summary Create user (dev only)
     * @request POST:/users/new
     */
    postUsers: (request: RoutesUsersNewRequest, params: RequestParams = {}) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/new`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns a user by ID
     *
     * @tags users
     * @name UsersDetail
     * @summary Get user by ID
     * @request GET:/users/{id}
     * @secure
     */
    usersDetail: (id: string, params: RequestParams = {}) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/${id}`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Updates a user by ID. Non-admins may only update themselves.
     *
     * @tags users
     * @name UsersCreate
     * @summary Update user
     * @request POST:/users/{id}
     * @secure
     */
    usersCreate: (
      id: string,
      request: RoutesUserUpdateRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/${id}`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Soft-deletes a user (for removing participants)
     *
     * @tags users
     * @name UsersDelete
     * @summary Delete user
     * @request DELETE:/users/{id}
     * @secure
     */
    usersDelete: (id: string, params: RequestParams = {}) =>
      this.request<void, HttpxErrorResponse>({
        path: `/users/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Generates a JWT token for a user. Only available in dev mode.
     *
     * @tags users
     * @name GetUsers2
     * @summary Generate JWT (dev only)
     * @request GET:/users/{id}/jwt
     * @originalName getUsers
     * @duplicate
     */
    getUsers2: (id: string, params: RequestParams = {}) =>
      this.request<RoutesUsersJwtResponse, HttpxErrorResponse>({
        path: `/users/${id}/jwt`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Sets a user's role in the system
     *
     * @tags users
     * @name RoleCreate
     * @summary Set user role
     * @request POST:/users/{id}/role
     * @secure
     */
    roleCreate: (
      id: string,
      request: RoutesSetUserRoleRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/${id}/role`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Removes a user's role
     *
     * @tags users
     * @name RoleDelete
     * @summary Remove user role
     * @request DELETE:/users/{id}/role
     * @secure
     */
    roleDelete: (id: string, params: RequestParams = {}) =>
      this.request<ObjUser, HttpxErrorResponse>({
        path: `/users/${id}/role`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),
  };
  version = {
    /**
     * @description Returns the server version and build time
     *
     * @tags status
     * @name VersionList
     * @summary Get server version
     * @request GET:/version
     */
    versionList: (params: RequestParams = {}) =>
      this.request<RoutesVersionResponse, any>({
        path: `/version`,
        method: "GET",
        format: "json",
        ...params,
      }),
  };
  workshops = {
    /**
     * @description Lists all workshops or workshops for a specific institution
     *
     * @tags workshops
     * @name WorkshopsList
     * @summary List workshops
     * @request GET:/workshops
     * @secure
     */
    workshopsList: (
      query?: {
        /** Institution ID */
        institutionId?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<ObjWorkshop[], HttpxErrorResponse>({
        path: `/workshops`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Creates a new workshop
     *
     * @tags workshops
     * @name WorkshopsCreate
     * @summary Create workshop
     * @request POST:/workshops
     * @secure
     */
    workshopsCreate: (
      request: RoutesCreateWorkshopRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjWorkshop, HttpxErrorResponse>({
        path: `/workshops`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Gets a workshop by ID
     *
     * @tags workshops
     * @name WorkshopsDetail
     * @summary Get workshop
     * @request GET:/workshops/{id}
     * @secure
     */
    workshopsDetail: (id: string, params: RequestParams = {}) =>
      this.request<ObjWorkshop, HttpxErrorResponse>({
        path: `/workshops/${id}`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Soft-deletes a workshop
     *
     * @tags workshops
     * @name WorkshopsDelete
     * @summary Delete workshop
     * @request DELETE:/workshops/{id}
     * @secure
     */
    workshopsDelete: (id: string, params: RequestParams = {}) =>
      this.request<Record<string, string>, HttpxErrorResponse>({
        path: `/workshops/${id}`,
        method: "DELETE",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Updates a workshop
     *
     * @tags workshops
     * @name WorkshopsPartialUpdate
     * @summary Update workshop
     * @request PATCH:/workshops/{id}
     * @secure
     */
    workshopsPartialUpdate: (
      id: string,
      request: RoutesUpdateWorkshopRequest,
      params: RequestParams = {},
    ) =>
      this.request<ObjWorkshop, HttpxErrorResponse>({
        path: `/workshops/${id}`,
        method: "PATCH",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
}
