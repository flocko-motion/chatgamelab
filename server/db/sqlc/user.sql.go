// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const acceptTargetedInvite = `-- name: AcceptTargetedInvite :exec
UPDATE user_role_invite SET
  status = 'accepted',
  accepted_at = now(),
  accepted_by = $2,
  modified_at = now()
WHERE id = $1
`

type AcceptTargetedInviteParams struct {
	ID         uuid.UUID
	AcceptedBy uuid.NullUUID
}

func (q *Queries) AcceptTargetedInvite(ctx context.Context, arg AcceptTargetedInviteParams) error {
	_, err := q.db.ExecContext(ctx, acceptTargetedInvite, arg.ID, arg.AcceptedBy)
	return err
}

const canUserAccessShareViaWorkshopDefault = `-- name: CanUserAccessShareViaWorkshopDefault :one
SELECT EXISTS(
  SELECT 1 FROM workshop w
  INNER JOIN user_role ur ON ur.workshop_id = w.id
  WHERE w.default_api_key_share_id = $1
    AND ur.user_id = $2
    AND w.active = true
    AND w.deleted_at IS NULL
) AS can_access
`

type CanUserAccessShareViaWorkshopDefaultParams struct {
	DefaultApiKeyShareID uuid.NullUUID
	UserID               uuid.UUID
}

// Check if a user can access an API key share because it's the default share for a workshop they're in
func (q *Queries) CanUserAccessShareViaWorkshopDefault(ctx context.Context, arg CanUserAccessShareViaWorkshopDefaultParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, canUserAccessShareViaWorkshopDefault, arg.DefaultApiKeyShareID, arg.UserID)
	var can_access bool
	err := row.Scan(&can_access)
	return can_access, err
}

const checkParticipantTokenStatus = `-- name: CheckParticipantTokenStatus :one
SELECT
  EXISTS(
    SELECT 1 FROM app_user u
    INNER JOIN user_role ur ON u.id = ur.user_id
    WHERE u.participant_token = $1
      AND u.deleted_at IS NULL
      AND ur.role = 'participant'
  ) AS token_exists,
  COALESCE(
    (SELECT w.active FROM app_user u
     INNER JOIN user_role ur ON u.id = ur.user_id
     INNER JOIN workshop w ON ur.workshop_id = w.id
     WHERE u.participant_token = $1
       AND u.deleted_at IS NULL
       AND ur.role = 'participant'
       AND w.deleted_at IS NULL
     LIMIT 1),
    false
  ) AS workshop_active
`

type CheckParticipantTokenStatusRow struct {
	TokenExists    bool
	WorkshopActive interface{}
}

// Check if a participant token exists and get the workshop active status
// Returns: exists (bool), workshop_active (bool)
func (q *Queries) CheckParticipantTokenStatus(ctx context.Context, participantToken sql.NullString) (CheckParticipantTokenStatusRow, error) {
	row := q.db.QueryRowContext(ctx, checkParticipantTokenStatus, participantToken)
	var i CheckParticipantTokenStatusRow
	err := row.Scan(&i.TokenExists, &i.WorkshopActive)
	return i, err
}

const clearDefaultApiKey = `-- name: ClearDefaultApiKey :exec
UPDATE api_key SET is_default = false, modified_at = now()
WHERE user_id = $1 AND is_default = true
`

func (q *Queries) ClearDefaultApiKey(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearDefaultApiKey, userID)
	return err
}

const clearUserActiveWorkshop = `-- name: ClearUserActiveWorkshop :exec
UPDATE user_role SET active_workshop_id = NULL, modified_at = now()
WHERE user_id = $1
`

func (q *Queries) ClearUserActiveWorkshop(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearUserActiveWorkshop, userID)
	return err
}

const countApiKeysByUser = `-- name: CountApiKeysByUser :one
SELECT COUNT(*) FROM api_key WHERE user_id = $1
`

func (q *Queries) CountApiKeysByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApiKeysByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGuestUsersByGameID = `-- name: CountGuestUsersByGameID :one
SELECT COUNT(*)::int AS count FROM app_user WHERE private_share_game_id = $1
`

func (q *Queries) CountGuestUsersByGameID(ctx context.Context, privateShareGameID uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countGuestUsersByGameID, privateShareGameID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countHeadsByInstitution = `-- name: CountHeadsByInstitution :one
SELECT COUNT(*)::int AS count
FROM user_role
WHERE institution_id = $1 AND role = 'head'
`

// Count how many heads an institution has (for last-head protection)
func (q *Queries) CountHeadsByInstitution(ctx context.Context, institutionID uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countHeadsByInstitution, institutionID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUserGames = `-- name: CountUserGames :one
SELECT COUNT(*)::int AS count FROM game WHERE created_by = $1
`

func (q *Queries) CountUserGames(ctx context.Context, createdBy uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserGames, createdBy)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUserPlayerMessages = `-- name: CountUserPlayerMessages :one
SELECT COUNT(*)::int AS count
FROM game_session_message m
JOIN game_session s ON s.id = m.game_session_id
WHERE s.user_id = $1 AND m.type = 'player'
`

func (q *Queries) CountUserPlayerMessages(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserPlayerMessages, userID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUserSessions = `-- name: CountUserSessions :one

SELECT COUNT(*)::int AS count FROM game_session WHERE user_id = $1
`

// User Statistics queries
func (q *Queries) CountUserSessions(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserSessions, userID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const createApiKey = `-- name: CreateApiKey :one

INSERT INTO api_key (
  id, created_by,
  created_at, modified_by, modified_at,
  user_id, name, platform, key, is_default
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, $6, $7, $8, $9
)
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key, is_default, last_usage_success
`

type CreateApiKeyParams struct {
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	Name       string
	Platform   string
	Key        string
	IsDefault  bool
}

// api_key --------------------------------------------------------------
func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createApiKey,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.UserID,
		arg.Name,
		arg.Platform,
		arg.Key,
		arg.IsDefault,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
		&i.IsDefault,
		&i.LastUsageSuccess,
	)
	return i, err
}

const createGuestUser = `-- name: CreateGuestUser :one

INSERT INTO app_user (id, name, email, auth0_id, participant_token, private_share_game_id)
VALUES ($1, $2, NULL, NULL, NULL, $3)
ON CONFLICT (id) DO NOTHING
RETURNING id
`

type CreateGuestUserParams struct {
	ID                 uuid.UUID
	Name               string
	PrivateShareGameID uuid.NullUUID
}

// Guest User queries
func (q *Queries) CreateGuestUser(ctx context.Context, arg CreateGuestUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createGuestUser, arg.ID, arg.Name, arg.PrivateShareGameID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createOpenInvite = `-- name: CreateOpenInvite :one
INSERT INTO user_role_invite (
  id, created_by, created_at, modified_by, modified_at,
  institution_id, role, workshop_id,
  invite_token, max_uses, expires_at,
  status
) VALUES (
  gen_random_uuid(), $1, now(), $1, now(),
  $2, $3, $4,
  $5, $6, $7,
  'pending'
)
RETURNING id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by
`

type CreateOpenInviteParams struct {
	CreatedBy     uuid.NullUUID
	InstitutionID uuid.UUID
	Role          string
	WorkshopID    uuid.NullUUID
	InviteToken   sql.NullString
	MaxUses       sql.NullInt32
	ExpiresAt     sql.NullTime
}

func (q *Queries) CreateOpenInvite(ctx context.Context, arg CreateOpenInviteParams) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, createOpenInvite,
		arg.CreatedBy,
		arg.InstitutionID,
		arg.Role,
		arg.WorkshopID,
		arg.InviteToken,
		arg.MaxUses,
		arg.ExpiresAt,
	)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const createTargetedInvite = `-- name: CreateTargetedInvite :one

INSERT INTO user_role_invite (
  id, created_by, created_at, modified_by, modified_at,
  institution_id, role, workshop_id,
  invited_user_id, invited_email,
  invite_token,
  status
) VALUES (
  gen_random_uuid(), $1, now(), $1, now(),
  $2, $3, $4,
  $5, $6,
  $7,
  'pending'
)
RETURNING id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by
`

type CreateTargetedInviteParams struct {
	CreatedBy     uuid.NullUUID
	InstitutionID uuid.UUID
	Role          string
	WorkshopID    uuid.NullUUID
	InvitedUserID uuid.NullUUID
	InvitedEmail  sql.NullString
	InviteToken   sql.NullString
}

// user_role_invite -------------------------------------------------------------
func (q *Queries) CreateTargetedInvite(ctx context.Context, arg CreateTargetedInviteParams) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, createTargetedInvite,
		arg.CreatedBy,
		arg.InstitutionID,
		arg.Role,
		arg.WorkshopID,
		arg.InvitedUserID,
		arg.InvitedEmail,
		arg.InviteToken,
	)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO app_user (id, name, email, auth0_id)
VALUES (gen_random_uuid(), $1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

// app_user -------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUserRole = `-- name: CreateUserRole :one
INSERT INTO user_role (id, user_id, role, institution_id, workshop_id)
VALUES (gen_random_uuid(), $1, $2, $3, $4)
RETURNING id
`

type CreateUserRoleParams struct {
	UserID        uuid.UUID
	Role          sql.NullString
	InstitutionID uuid.NullUUID
	WorkshopID    uuid.NullUUID
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, createUserRole,
		arg.UserID,
		arg.Role,
		arg.InstitutionID,
		arg.WorkshopID,
	)
	var id uuid.NullUUID
	err := row.Scan(&id)
	return id, err
}

const createUserWithID = `-- name: CreateUserWithID :one
INSERT INTO app_user (id, name, email, auth0_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
RETURNING id
`

type CreateUserWithIDParams struct {
	ID      uuid.UUID
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

func (q *Queries) CreateUserWithID(ctx context.Context, arg CreateUserWithIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserWithID,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Auth0ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUserWithParticipantToken = `-- name: CreateUserWithParticipantToken :one
INSERT INTO app_user (id, name, email, auth0_id, participant_token)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO NOTHING
RETURNING id
`

type CreateUserWithParticipantTokenParams struct {
	ID               uuid.UUID
	Name             string
	Email            sql.NullString
	Auth0ID          sql.NullString
	ParticipantToken sql.NullString
}

func (q *Queries) CreateUserWithParticipantToken(ctx context.Context, arg CreateUserWithParticipantTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserWithParticipantToken,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Auth0ID,
		arg.ParticipantToken,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteAllApiKeysByUser = `-- name: DeleteAllApiKeysByUser :exec
DELETE FROM api_key WHERE user_id = $1
`

func (q *Queries) DeleteAllApiKeysByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAllApiKeysByUser, userID)
	return err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM api_key WHERE id = $1 AND user_id = $2
`

type DeleteApiKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteApiKey(ctx context.Context, arg DeleteApiKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteApiKey, arg.ID, arg.UserID)
	return err
}

const deleteGuestSessionMessagesByGameID = `-- name: DeleteGuestSessionMessagesByGameID :exec
DELETE FROM game_session_message WHERE game_session_id IN (
  SELECT gs.id FROM game_session gs
  JOIN app_user u ON u.id = gs.user_id
  WHERE u.private_share_game_id = $1
)
`

// Delete all messages belonging to sessions of guest users created via a game's share link
func (q *Queries) DeleteGuestSessionMessagesByGameID(ctx context.Context, privateShareGameID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteGuestSessionMessagesByGameID, privateShareGameID)
	return err
}

const deleteGuestSessionsByGameID = `-- name: DeleteGuestSessionsByGameID :exec
DELETE FROM game_session WHERE user_id IN (
  SELECT id FROM app_user WHERE private_share_game_id = $1
)
`

// Delete all sessions of guest users created via a game's share link
func (q *Queries) DeleteGuestSessionsByGameID(ctx context.Context, privateShareGameID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteGuestSessionsByGameID, privateShareGameID)
	return err
}

const deleteGuestUsersByGameID = `-- name: DeleteGuestUsersByGameID :exec
DELETE FROM app_user WHERE private_share_game_id = $1
`

// Delete all guest users created via a game's share link
func (q *Queries) DeleteGuestUsersByGameID(ctx context.Context, privateShareGameID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteGuestUsersByGameID, privateShareGameID)
	return err
}

const deleteInvite = `-- name: DeleteInvite :exec
DELETE FROM user_role_invite WHERE id = $1
`

func (q *Queries) DeleteInvite(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvite, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE app_user
SET
  deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteUserFavourites = `-- name: DeleteUserFavourites :exec

DELETE FROM user_favourite_game WHERE user_id = $1
`

// User deletion cleanup queries
func (q *Queries) DeleteUserFavourites(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserFavourites, userID)
	return err
}

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM user_role WHERE user_id = $1
`

func (q *Queries) DeleteUserRole(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserRole, userID)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec

DELETE FROM user_role WHERE user_id = $1
`

// user_role -------------------------------------------------------------
func (q *Queries) DeleteUserRoles(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserRoles, userID)
	return err
}

const deleteUserRolesByWorkshopID = `-- name: DeleteUserRolesByWorkshopID :exec
DELETE FROM user_role WHERE workshop_id = $1 AND role = 'participant'
`

// Delete all participant roles scoped to a workshop
func (q *Queries) DeleteUserRolesByWorkshopID(ctx context.Context, workshopID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserRolesByWorkshopID, workshopID)
	return err
}

const deleteWorkshopParticipantsByUserID = `-- name: DeleteWorkshopParticipantsByUserID :exec
DELETE FROM workshop_participant WHERE workshop_id IN (
  SELECT workshop_id FROM user_role WHERE user_id = $1 AND role = 'participant' AND workshop_id IS NOT NULL
)
`

func (q *Queries) DeleteWorkshopParticipantsByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteWorkshopParticipantsByUserID, userID)
	return err
}

const getAllUsersWithDetails = `-- name: GetAllUsersWithDetails :many
SELECT
  u.id,
  u.created_by,
  u.created_at,
  u.modified_by,
  u.modified_at,
  u.name,
  u.email,
  u.deleted_at,
  u.auth0_id,
  r.id           AS role_id,
  r.role         AS role,
  r.institution_id,
  i.name         AS institution_name,
  r.workshop_id,
  w.name         AS workshop_name
FROM app_user u
LEFT JOIN LATERAL (
  SELECT ur.id, ur.created_by, ur.created_at, ur.modified_by, ur.modified_at, ur.user_id, ur.role, ur.institution_id, ur.workshop_id, ur.active_workshop_id
  FROM user_role ur
  WHERE ur.user_id = u.id
  ORDER BY ur.created_at DESC
  LIMIT 1
) r ON TRUE
LEFT JOIN institution i
  ON i.id = r.institution_id
LEFT JOIN workshop w
  ON w.id = r.workshop_id
WHERE u.deleted_at IS NULL
ORDER BY u.created_at DESC
`

type GetAllUsersWithDetailsRow struct {
	ID              uuid.UUID
	CreatedBy       uuid.NullUUID
	CreatedAt       time.Time
	ModifiedBy      uuid.NullUUID
	ModifiedAt      time.Time
	Name            string
	Email           sql.NullString
	DeletedAt       sql.NullTime
	Auth0ID         sql.NullString
	RoleID          uuid.NullUUID
	Role            sql.NullString
	InstitutionID   uuid.NullUUID
	InstitutionName sql.NullString
	WorkshopID      uuid.NullUUID
	WorkshopName    sql.NullString
}

func (q *Queries) GetAllUsersWithDetails(ctx context.Context) ([]GetAllUsersWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersWithDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithDetailsRow
	for rows.Next() {
		var i GetAllUsersWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Email,
			&i.DeletedAt,
			&i.Auth0ID,
			&i.RoleID,
			&i.Role,
			&i.InstitutionID,
			&i.InstitutionName,
			&i.WorkshopID,
			&i.WorkshopName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeyByID = `-- name: GetApiKeyByID :one
SELECT id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key, is_default, last_usage_success FROM api_key WHERE id = $1
`

func (q *Queries) GetApiKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
		&i.IsDefault,
		&i.LastUsageSuccess,
	)
	return i, err
}

const getApiKeyIDsByUser = `-- name: GetApiKeyIDsByUser :many
SELECT id FROM api_key WHERE user_id = $1
`

func (q *Queries) GetApiKeyIDsByUser(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeyIDsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultApiKey = `-- name: GetDefaultApiKey :one
SELECT id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key, is_default, last_usage_success FROM api_key WHERE user_id = $1 AND is_default = true
`

func (q *Queries) GetDefaultApiKey(ctx context.Context, userID uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getDefaultApiKey, userID)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
		&i.IsDefault,
		&i.LastUsageSuccess,
	)
	return i, err
}

const getInviteByID = `-- name: GetInviteByID :one
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite WHERE id = $1
`

func (q *Queries) GetInviteByID(ctx context.Context, id uuid.UUID) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByID, id)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInviteByToken = `-- name: GetInviteByToken :one
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite WHERE invite_token = $1
`

func (q *Queries) GetInviteByToken(ctx context.Context, inviteToken sql.NullString) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByToken, inviteToken)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInvites = `-- name: GetInvites :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetInvites(ctx context.Context) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitesByInstitution = `-- name: GetInvitesByInstitution :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite
WHERE institution_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByInstitution(ctx context.Context, institutionID uuid.UUID) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvitesByInstitution, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitesByUser = `-- name: GetInvitesByUser :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite
WHERE (invited_user_id = $1 OR invited_email = (SELECT email FROM app_user WHERE id = $1))
  AND deleted_at IS NULL
  AND status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByUser(ctx context.Context, invitedUserID uuid.NullUUID) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvitesByUser, invitedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitesByWorkshop = `-- name: GetInvitesByWorkshop :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite
WHERE workshop_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByWorkshop(ctx context.Context, workshopID uuid.NullUUID) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvitesByWorkshop, workshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantUserIDsByWorkshopID = `-- name: GetParticipantUserIDsByWorkshopID :many
SELECT user_id FROM user_role WHERE workshop_id = $1 AND role = 'participant'
`

// Get user IDs of participants in a workshop
func (q *Queries) GetParticipantUserIDsByWorkshopID(ctx context.Context, workshopID uuid.NullUUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getParticipantUserIDsByWorkshopID, workshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInviteByTarget = `-- name: GetPendingInviteByTarget :one
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite
WHERE institution_id = $1
  AND status = 'pending'
  AND deleted_at IS NULL
  AND (
    (invited_user_id IS NOT NULL AND invited_user_id = $2)
    OR (invited_email IS NOT NULL AND invited_email = $3)
  )
LIMIT 1
`

type GetPendingInviteByTargetParams struct {
	InstitutionID uuid.UUID
	InvitedUserID uuid.NullUUID
	InvitedEmail  sql.NullString
}

// Check if a pending invite already exists for the same target (user_id or email) and institution
func (q *Queries) GetPendingInviteByTarget(ctx context.Context, arg GetPendingInviteByTargetParams) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, getPendingInviteByTarget, arg.InstitutionID, arg.InvitedUserID, arg.InvitedEmail)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getUserActiveWorkshopID = `-- name: GetUserActiveWorkshopID :one
SELECT active_workshop_id FROM user_role
WHERE user_id = $1 AND active_workshop_id IS NOT NULL
LIMIT 1
`

// Get the active workshop ID for a user (for game creation context)
func (q *Queries) GetUserActiveWorkshopID(ctx context.Context, userID uuid.UUID) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getUserActiveWorkshopID, userID)
	var active_workshop_id uuid.NullUUID
	err := row.Scan(&active_workshop_id)
	return active_workshop_id, err
}

const getUserApiKeys = `-- name: GetUserApiKeys :many
SELECT
  k.id,
  k.created_by,
  k.created_at,
  k.modified_by,
  k.modified_at,
  k.user_id,
  u.name AS user_name,
  k.name,
  k.platform,
  k.key
FROM api_key k
JOIN app_user u ON u.id = k.user_id
WHERE k.user_id = $1
`

type GetUserApiKeysRow struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	UserName   string
	Name       string
	Platform   string
	Key        string
}

func (q *Queries) GetUserApiKeys(ctx context.Context, userID uuid.UUID) ([]GetUserApiKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserApiKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserApiKeysRow
	for rows.Next() {
		var i GetUserApiKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.UserID,
			&i.UserName,
			&i.Name,
			&i.Platform,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByAuth0ID = `-- name: GetUserByAuth0ID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, email, deleted_at, auth0_id, participant_token, default_api_key_share_id, ai_quality_tier, language, private_share_game_id FROM app_user WHERE auth0_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByAuth0ID(ctx context.Context, auth0ID sql.NullString) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByAuth0ID, auth0ID)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.ParticipantToken,
		&i.DefaultApiKeyShareID,
		&i.AiQualityTier,
		&i.Language,
		&i.PrivateShareGameID,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_by, created_at, modified_by, modified_at, name, email, deleted_at, auth0_id, participant_token, default_api_key_share_id, ai_quality_tier, language, private_share_game_id FROM app_user WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.ParticipantToken,
		&i.DefaultApiKeyShareID,
		&i.AiQualityTier,
		&i.Language,
		&i.PrivateShareGameID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, email, deleted_at, auth0_id, participant_token, default_api_key_share_id, ai_quality_tier, language, private_share_game_id FROM app_user WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.ParticipantToken,
		&i.DefaultApiKeyShareID,
		&i.AiQualityTier,
		&i.Language,
		&i.PrivateShareGameID,
	)
	return i, err
}

const getUserByParticipantToken = `-- name: GetUserByParticipantToken :one
SELECT u.id, u.created_by, u.created_at, u.modified_by, u.modified_at, u.name, u.email, u.deleted_at, u.auth0_id, u.participant_token, u.default_api_key_share_id, u.ai_quality_tier, u.language, u.private_share_game_id
FROM app_user u
INNER JOIN user_role ur ON u.id = ur.user_id
INNER JOIN workshop w ON ur.workshop_id = w.id
WHERE u.participant_token = $1
  AND u.deleted_at IS NULL
  AND ur.role = 'participant'
  AND w.active = true
  AND w.deleted_at IS NULL
`

// Get user by participant token, but only if they're linked to an active workshop
func (q *Queries) GetUserByParticipantToken(ctx context.Context, participantToken sql.NullString) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByParticipantToken, participantToken)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.ParticipantToken,
		&i.DefaultApiKeyShareID,
		&i.AiQualityTier,
		&i.Language,
		&i.PrivateShareGameID,
	)
	return i, err
}

const getUserDefaultApiKeyShare = `-- name: GetUserDefaultApiKeyShare :one
SELECT default_api_key_share_id FROM app_user WHERE id = $1
`

func (q *Queries) GetUserDefaultApiKeyShare(ctx context.Context, id uuid.UUID) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getUserDefaultApiKeyShare, id)
	var default_api_key_share_id uuid.NullUUID
	err := row.Scan(&default_api_key_share_id)
	return default_api_key_share_id, err
}

const getUserDetailsByID = `-- name: GetUserDetailsByID :one
SELECT
  u.id,
  u.created_by,
  u.created_at,
  u.modified_by,
  u.modified_at,
  u.name,
  u.email,
  u.deleted_at,
  u.auth0_id,
  u.default_api_key_share_id,
  u.ai_quality_tier,
  u.language,
  r.id           AS role_id,
  r.role         AS role,
  r.institution_id,
  i.name         AS institution_name,
  r.workshop_id,
  w.name         AS workshop_name,
  w.show_public_games AS workshop_show_public_games,
  w.show_other_participants_games AS workshop_show_other_participants_games,
  w.ai_quality_tier AS workshop_ai_quality_tier,
  r.active_workshop_id,
  aw.name        AS active_workshop_name,
  aw.show_public_games AS active_workshop_show_public_games,
  aw.show_other_participants_games AS active_workshop_show_other_participants_games,
  aw.ai_quality_tier AS active_workshop_ai_quality_tier
FROM app_user u
LEFT JOIN LATERAL (
  SELECT ur.id, ur.created_by, ur.created_at, ur.modified_by, ur.modified_at, ur.user_id, ur.role, ur.institution_id, ur.workshop_id, ur.active_workshop_id
  FROM user_role ur
  WHERE ur.user_id = u.id
  ORDER BY ur.created_at DESC
  LIMIT 1
) r ON TRUE
LEFT JOIN institution i
  ON i.id = r.institution_id
LEFT JOIN workshop w
  ON w.id = r.workshop_id
LEFT JOIN workshop aw
  ON aw.id = r.active_workshop_id
WHERE u.id = $1
`

type GetUserDetailsByIDRow struct {
	ID                                       uuid.UUID
	CreatedBy                                uuid.NullUUID
	CreatedAt                                time.Time
	ModifiedBy                               uuid.NullUUID
	ModifiedAt                               time.Time
	Name                                     string
	Email                                    sql.NullString
	DeletedAt                                sql.NullTime
	Auth0ID                                  sql.NullString
	DefaultApiKeyShareID                     uuid.NullUUID
	AiQualityTier                            sql.NullString
	Language                                 string
	RoleID                                   uuid.NullUUID
	Role                                     sql.NullString
	InstitutionID                            uuid.NullUUID
	InstitutionName                          sql.NullString
	WorkshopID                               uuid.NullUUID
	WorkshopName                             sql.NullString
	WorkshopShowPublicGames                  sql.NullBool
	WorkshopShowOtherParticipantsGames       sql.NullBool
	WorkshopAiQualityTier                    sql.NullString
	ActiveWorkshopID                         uuid.NullUUID
	ActiveWorkshopName                       sql.NullString
	ActiveWorkshopShowPublicGames            sql.NullBool
	ActiveWorkshopShowOtherParticipantsGames sql.NullBool
	ActiveWorkshopAiQualityTier              sql.NullString
}

func (q *Queries) GetUserDetailsByID(ctx context.Context, id uuid.UUID) (GetUserDetailsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetailsByID, id)
	var i GetUserDetailsByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.DefaultApiKeyShareID,
		&i.AiQualityTier,
		&i.Language,
		&i.RoleID,
		&i.Role,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.WorkshopID,
		&i.WorkshopName,
		&i.WorkshopShowPublicGames,
		&i.WorkshopShowOtherParticipantsGames,
		&i.WorkshopAiQualityTier,
		&i.ActiveWorkshopID,
		&i.ActiveWorkshopName,
		&i.ActiveWorkshopShowPublicGames,
		&i.ActiveWorkshopShowOtherParticipantsGames,
		&i.ActiveWorkshopAiQualityTier,
	)
	return i, err
}

const getUserIDByAuth0ID = `-- name: GetUserIDByAuth0ID :one
SELECT id FROM app_user WHERE auth0_id = $1
`

func (q *Queries) GetUserIDByAuth0ID(ctx context.Context, auth0ID sql.NullString) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByAuth0ID, auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUsersByInstitution = `-- name: GetUsersByInstitution :many
SELECT
  u.id, u.name, u.email,
  u.created_by, u.created_at, u.modified_by, u.modified_at,
  ur.id as role_id, ur.role as role_role
FROM app_user u
INNER JOIN user_role ur ON u.id = ur.user_id
WHERE ur.institution_id = $1
  AND u.deleted_at IS NULL
  AND ur.role IN ('individual', 'staff', 'head')
`

type GetUsersByInstitutionRow struct {
	ID         uuid.UUID
	Name       string
	Email      sql.NullString
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	RoleID     uuid.NullUUID
	RoleRole   sql.NullString
}

func (q *Queries) GetUsersByInstitution(ctx context.Context, institutionID uuid.NullUUID) ([]GetUsersByInstitutionRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByInstitution, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByInstitutionRow
	for rows.Next() {
		var i GetUsersByInstitutionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.RoleID,
			&i.RoleRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByWorkshop = `-- name: GetUsersByWorkshop :many
SELECT
  u.id, u.name, u.email,
  u.created_by, u.created_at, u.modified_by, u.modified_at,
  u.deleted_at, u.auth0_id,
  ur.id as role_id, ur.role, ur.institution_id, ur.workshop_id
FROM app_user u
INNER JOIN user_role ur ON u.id = ur.user_id
WHERE ur.workshop_id = $1
  AND u.deleted_at IS NULL
`

type GetUsersByWorkshopRow struct {
	ID            uuid.UUID
	Name          string
	Email         sql.NullString
	CreatedBy     uuid.NullUUID
	CreatedAt     time.Time
	ModifiedBy    uuid.NullUUID
	ModifiedAt    time.Time
	DeletedAt     sql.NullTime
	Auth0ID       sql.NullString
	RoleID        uuid.NullUUID
	Role          sql.NullString
	InstitutionID uuid.NullUUID
	WorkshopID    uuid.NullUUID
}

func (q *Queries) GetUsersByWorkshop(ctx context.Context, workshopID uuid.NullUUID) ([]GetUsersByWorkshopRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByWorkshop, workshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByWorkshopRow
	for rows.Next() {
		var i GetUsersByWorkshopRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.Auth0ID,
			&i.RoleID,
			&i.Role,
			&i.InstitutionID,
			&i.WorkshopID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkshopParticipants = `-- name: GetWorkshopParticipants :many
SELECT
  u.id, u.name, u.auth0_id,
  COALESCE(ur.created_at, w.created_at) as joined_at,
  COALESCE(ur.role, ur_inst.role) as role,
  (SELECT COUNT(*) FROM game g WHERE g.created_by = u.id AND g.deleted_at IS NULL)::int as games_count
FROM app_user u
INNER JOIN workshop w ON w.id = $1
LEFT JOIN user_role ur ON u.id = ur.user_id AND ur.workshop_id = $1 AND ur.role = 'participant'
LEFT JOIN user_role ur_inst ON u.id = ur_inst.user_id AND ur_inst.workshop_id IS NULL AND u.id = w.created_by
WHERE (ur.user_id IS NOT NULL OR u.id = w.created_by)
  AND u.deleted_at IS NULL
ORDER BY joined_at ASC
`

type GetWorkshopParticipantsRow struct {
	ID         uuid.UUID
	Name       string
	Auth0ID    sql.NullString
	JoinedAt   time.Time
	Role       sql.NullString
	GamesCount int32
}

// Get all participants for a workshop, including:
// 1. Users with RoleParticipant (anonymous participants)
// 2. Workshop owner/creator (staff/head who created it)
func (q *Queries) GetWorkshopParticipants(ctx context.Context, id uuid.UUID) ([]GetWorkshopParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkshopParticipants, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkshopParticipantsRow
	for rows.Next() {
		var i GetWorkshopParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Auth0ID,
			&i.JoinedAt,
			&i.Role,
			&i.GamesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasWorkshopRole = `-- name: HasWorkshopRole :one
SELECT EXISTS(
    SELECT 1 FROM user_role
    WHERE user_id = $1 AND workshop_id = $2
) AS has_role
`

type HasWorkshopRoleParams struct {
	UserID     uuid.UUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) HasWorkshopRole(ctx context.Context, arg HasWorkshopRoleParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasWorkshopRole, arg.UserID, arg.WorkshopID)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const incrementInviteUses = `-- name: IncrementInviteUses :exec
UPDATE user_role_invite SET
  uses_count = uses_count + 1,
  modified_at = now()
WHERE id = $1
`

func (q *Queries) IncrementInviteUses(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementInviteUses, id)
	return err
}

const isEmailTakenByOther = `-- name: IsEmailTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE email = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsEmailTakenByOtherParams struct {
	Email sql.NullString
	ID    uuid.UUID
}

func (q *Queries) IsEmailTakenByOther(ctx context.Context, arg IsEmailTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isEmailTakenByOther, arg.Email, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTaken = `-- name: IsNameTaken :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND deleted_at IS NULL) AS taken
`

func (q *Queries) IsNameTaken(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTaken, name)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTakenByOther = `-- name: IsNameTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsNameTakenByOtherParams struct {
	Name string
	ID   uuid.UUID
}

func (q *Queries) IsNameTakenByOther(ctx context.Context, arg IsNameTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTakenByOther, arg.Name, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isUserInWorkshop = `-- name: IsUserInWorkshop :one
SELECT EXISTS(
  SELECT 1 FROM user_role ur
  INNER JOIN workshop w ON w.id = ur.workshop_id
  WHERE ur.user_id = $1
    AND ur.workshop_id = $2
    AND w.active = true
    AND w.deleted_at IS NULL
) AS is_member
`

type IsUserInWorkshopParams struct {
	UserID     uuid.UUID
	WorkshopID uuid.NullUUID
}

// Check if a user is a member of a specific workshop (has a user_role with that workshop_id)
func (q *Queries) IsUserInWorkshop(ctx context.Context, arg IsUserInWorkshopParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserInWorkshop, arg.UserID, arg.WorkshopID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const setDefaultApiKey = `-- name: SetDefaultApiKey :exec
UPDATE api_key SET is_default = true, modified_at = now()
WHERE id = $1 AND user_id = $2
`

type SetDefaultApiKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) SetDefaultApiKey(ctx context.Context, arg SetDefaultApiKeyParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultApiKey, arg.ID, arg.UserID)
	return err
}

const setUserActiveWorkshop = `-- name: SetUserActiveWorkshop :exec

UPDATE user_role SET active_workshop_id = $2, modified_at = now()
WHERE user_id = $1
`

type SetUserActiveWorkshopParams struct {
	UserID           uuid.UUID
	ActiveWorkshopID uuid.NullUUID
}

// active_workshop ------------------------------------------------------
func (q *Queries) SetUserActiveWorkshop(ctx context.Context, arg SetUserActiveWorkshopParams) error {
	_, err := q.db.ExecContext(ctx, setUserActiveWorkshop, arg.UserID, arg.ActiveWorkshopID)
	return err
}

const setUserDefaultApiKeyShare = `-- name: SetUserDefaultApiKeyShare :exec

UPDATE app_user SET
  default_api_key_share_id = $2,
  modified_at = now()
WHERE id = $1
`

type SetUserDefaultApiKeyShareParams struct {
	ID                   uuid.UUID
	DefaultApiKeyShareID uuid.NullUUID
}

// GetApiKeySharesByUserID is now in api_key.sql using the unified api_key_share table
func (q *Queries) SetUserDefaultApiKeyShare(ctx context.Context, arg SetUserDefaultApiKeyShareParams) error {
	_, err := q.db.ExecContext(ctx, setUserDefaultApiKeyShare, arg.ID, arg.DefaultApiKeyShareID)
	return err
}

const sumPlayCountOfUserGames = `-- name: SumPlayCountOfUserGames :one
SELECT COALESCE(SUM(play_count), 0)::int AS total FROM game WHERE created_by = $1
`

func (q *Queries) SumPlayCountOfUserGames(ctx context.Context, createdBy uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, sumPlayCountOfUserGames, createdBy)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE api_key SET
  modified_by = $2,
  modified_at = $3,
  name = $4
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key, is_default, last_usage_success
`

type UpdateApiKeyParams struct {
	ID         uuid.UUID
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	Name       string
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKey,
		arg.ID,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
		&i.IsDefault,
		&i.LastUsageSuccess,
	)
	return i, err
}

const updateApiKeyLastUsageSuccess = `-- name: UpdateApiKeyLastUsageSuccess :exec
UPDATE api_key SET last_usage_success = $2, modified_at = now()
WHERE id = $1
`

type UpdateApiKeyLastUsageSuccessParams struct {
	ID               uuid.UUID
	LastUsageSuccess sql.NullBool
}

func (q *Queries) UpdateApiKeyLastUsageSuccess(ctx context.Context, arg UpdateApiKeyLastUsageSuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateApiKeyLastUsageSuccess, arg.ID, arg.LastUsageSuccess)
	return err
}

const updateInviteStatus = `-- name: UpdateInviteStatus :exec
UPDATE user_role_invite SET
  status = $2,
  modified_at = now()
WHERE id = $1
`

type UpdateInviteStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) UpdateInviteStatus(ctx context.Context, arg UpdateInviteStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateInviteStatus, arg.ID, arg.Status)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE app_user SET
  name = $2,
  email = $3,
  modified_at = now()
WHERE id = $1
`

type UpdateUserParams struct {
	ID    uuid.UUID
	Name  string
	Email sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	return err
}

const updateUserAiQualityTier = `-- name: UpdateUserAiQualityTier :exec
UPDATE app_user SET
  ai_quality_tier = $2,
  modified_at = now()
WHERE id = $1
`

type UpdateUserAiQualityTierParams struct {
	ID            uuid.UUID
	AiQualityTier sql.NullString
}

func (q *Queries) UpdateUserAiQualityTier(ctx context.Context, arg UpdateUserAiQualityTierParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAiQualityTier, arg.ID, arg.AiQualityTier)
	return err
}

const updateUserLanguage = `-- name: UpdateUserLanguage :exec
UPDATE app_user SET
  language = $2,
  modified_at = now()
WHERE id = $1
`

type UpdateUserLanguageParams struct {
	ID       uuid.UUID
	Language string
}

func (q *Queries) UpdateUserLanguage(ctx context.Context, arg UpdateUserLanguageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLanguage, arg.ID, arg.Language)
	return err
}
