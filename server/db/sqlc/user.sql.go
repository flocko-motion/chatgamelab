// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countUserGames = `-- name: CountUserGames :one
SELECT COUNT(*)::int AS count FROM game WHERE created_by = $1
`

func (q *Queries) CountUserGames(ctx context.Context, createdBy uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserGames, createdBy)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUserPlayerMessages = `-- name: CountUserPlayerMessages :one
SELECT COUNT(*)::int AS count
FROM game_session_message m
JOIN game_session s ON s.id = m.game_session_id
WHERE s.user_id = $1 AND m.type = 'player'
`

func (q *Queries) CountUserPlayerMessages(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserPlayerMessages, userID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUserSessions = `-- name: CountUserSessions :one

SELECT COUNT(*)::int AS count FROM game_session WHERE user_id = $1
`

// User Statistics queries
func (q *Queries) CountUserSessions(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUserSessions, userID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const createApiKey = `-- name: CreateApiKey :one

INSERT INTO api_key (
  id, created_by,
  created_at, modified_by, modified_at,
  user_id, name, platform, key
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, $6, $7, $8
)
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key
`

type CreateApiKeyParams struct {
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	Name       string
	Platform   string
	Key        string
}

// api_key --------------------------------------------------------------
func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createApiKey,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.UserID,
		arg.Name,
		arg.Platform,
		arg.Key,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO app_user (id, name, email, auth0_id)
VALUES (gen_random_uuid(), $1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

// app_user -------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUserRole = `-- name: CreateUserRole :one
INSERT INTO user_role (id, user_id, role, institution_id)
VALUES (gen_random_uuid(), $1, $2, $3)
RETURNING id
`

type CreateUserRoleParams struct {
	UserID        uuid.UUID
	Role          sql.NullString
	InstitutionID uuid.NullUUID
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, createUserRole, arg.UserID, arg.Role, arg.InstitutionID)
	var id uuid.NullUUID
	err := row.Scan(&id)
	return id, err
}

const createUserWithID = `-- name: CreateUserWithID :one
INSERT INTO app_user (id, name, email, auth0_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
RETURNING id
`

type CreateUserWithIDParams struct {
	ID      uuid.UUID
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

func (q *Queries) CreateUserWithID(ctx context.Context, arg CreateUserWithIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserWithID,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Auth0ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM api_key WHERE id = $1 AND user_id = $2
`

type DeleteApiKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteApiKey(ctx context.Context, arg DeleteApiKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteApiKey, arg.ID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE app_user
SET
  deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec

DELETE FROM user_role WHERE user_id = $1
`

// user_role -------------------------------------------------------------
func (q *Queries) DeleteUserRoles(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserRoles, userID)
	return err
}

const getApiKeyByID = `-- name: GetApiKeyByID :one
SELECT id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key FROM api_key WHERE id = $1
`

func (q *Queries) GetApiKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const getUserApiKeys = `-- name: GetUserApiKeys :many
SELECT
  k.id,
  k.created_by,
  k.created_at,
  k.modified_by,
  k.modified_at,
  k.user_id,
  u.name AS user_name,
  k.name,
  k.platform,
  k.key
FROM api_key k
JOIN app_user u ON u.id = k.user_id
WHERE k.user_id = $1
`

type GetUserApiKeysRow struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	UserName   string
	Name       string
	Platform   string
	Key        string
}

func (q *Queries) GetUserApiKeys(ctx context.Context, userID uuid.UUID) ([]GetUserApiKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserApiKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserApiKeysRow
	for rows.Next() {
		var i GetUserApiKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.UserID,
			&i.UserName,
			&i.Name,
			&i.Platform,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, email, deleted_at, auth0_id, default_api_key_share_id, show_ai_model_selector FROM app_user WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.DefaultApiKeyShareID,
		&i.ShowAiModelSelector,
	)
	return i, err
}

const getUserDefaultApiKeyShare = `-- name: GetUserDefaultApiKeyShare :one
SELECT default_api_key_share_id FROM app_user WHERE id = $1
`

func (q *Queries) GetUserDefaultApiKeyShare(ctx context.Context, id uuid.UUID) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getUserDefaultApiKeyShare, id)
	var default_api_key_share_id uuid.NullUUID
	err := row.Scan(&default_api_key_share_id)
	return default_api_key_share_id, err
}

const getUserDetailsByID = `-- name: GetUserDetailsByID :one
SELECT
  u.id,
  u.created_by,
  u.created_at,
  u.modified_by,
  u.modified_at,
  u.name,
  u.email,
  u.deleted_at,
  u.auth0_id,
  u.default_api_key_share_id,
  u.show_ai_model_selector,
  r.id           AS role_id,
  r.role         AS role,
  r.institution_id,
  i.name         AS institution_name
FROM app_user u
LEFT JOIN LATERAL (
  SELECT ur.id, ur.created_by, ur.created_at, ur.modified_by, ur.modified_at, ur.user_id, ur.role, ur.institution_id
  FROM user_role ur
  WHERE ur.user_id = u.id
  ORDER BY ur.created_at DESC
  LIMIT 1
) r ON TRUE
LEFT JOIN institution i
  ON i.id = r.institution_id
WHERE u.id = $1
`

type GetUserDetailsByIDRow struct {
	ID                   uuid.UUID
	CreatedBy            uuid.NullUUID
	CreatedAt            time.Time
	ModifiedBy           uuid.NullUUID
	ModifiedAt           time.Time
	Name                 string
	Email                sql.NullString
	DeletedAt            sql.NullTime
	Auth0ID              sql.NullString
	DefaultApiKeyShareID uuid.NullUUID
	ShowAiModelSelector  bool
	RoleID               uuid.NullUUID
	Role                 sql.NullString
	InstitutionID        uuid.NullUUID
	InstitutionName      sql.NullString
}

func (q *Queries) GetUserDetailsByID(ctx context.Context, id uuid.UUID) (GetUserDetailsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetailsByID, id)
	var i GetUserDetailsByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.DefaultApiKeyShareID,
		&i.ShowAiModelSelector,
		&i.RoleID,
		&i.Role,
		&i.InstitutionID,
		&i.InstitutionName,
	)
	return i, err
}

const getUserIDByAuth0ID = `-- name: GetUserIDByAuth0ID :one
SELECT id FROM app_user WHERE auth0_id = $1
`

func (q *Queries) GetUserIDByAuth0ID(ctx context.Context, auth0ID sql.NullString) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByAuth0ID, auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const isEmailTakenByOther = `-- name: IsEmailTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE email = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsEmailTakenByOtherParams struct {
	Email sql.NullString
	ID    uuid.UUID
}

func (q *Queries) IsEmailTakenByOther(ctx context.Context, arg IsEmailTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isEmailTakenByOther, arg.Email, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTaken = `-- name: IsNameTaken :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND deleted_at IS NULL) AS taken
`

func (q *Queries) IsNameTaken(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTaken, name)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTakenByOther = `-- name: IsNameTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsNameTakenByOtherParams struct {
	Name string
	ID   uuid.UUID
}

func (q *Queries) IsNameTakenByOther(ctx context.Context, arg IsNameTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTakenByOther, arg.Name, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const setUserDefaultApiKeyShare = `-- name: SetUserDefaultApiKeyShare :exec

UPDATE app_user SET
  default_api_key_share_id = $2,
  modified_at = now()
WHERE id = $1
`

type SetUserDefaultApiKeyShareParams struct {
	ID                   uuid.UUID
	DefaultApiKeyShareID uuid.NullUUID
}

// GetApiKeySharesByUserID is now in api_key.sql using the unified api_key_share table
func (q *Queries) SetUserDefaultApiKeyShare(ctx context.Context, arg SetUserDefaultApiKeyShareParams) error {
	_, err := q.db.ExecContext(ctx, setUserDefaultApiKeyShare, arg.ID, arg.DefaultApiKeyShareID)
	return err
}

const sumPlayCountOfUserGames = `-- name: SumPlayCountOfUserGames :one
SELECT COALESCE(SUM(play_count), 0)::int AS total FROM game WHERE created_by = $1
`

func (q *Queries) SumPlayCountOfUserGames(ctx context.Context, createdBy uuid.NullUUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, sumPlayCountOfUserGames, createdBy)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE api_key SET
  modified_by = $2,
  modified_at = $3,
  name = $4
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key
`

type UpdateApiKeyParams struct {
	ID         uuid.UUID
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	Name       string
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKey,
		arg.ID,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE app_user SET
  name = $2,
  email = $3,
  modified_at = now()
WHERE id = $1
`

type UpdateUserParams struct {
	ID    uuid.UUID
	Name  string
	Email sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	return err
}

const updateUserSettings = `-- name: UpdateUserSettings :exec
UPDATE app_user SET
  show_ai_model_selector = $2,
  modified_at = now()
WHERE id = $1
`

type UpdateUserSettingsParams struct {
	ID                  uuid.UUID
	ShowAiModelSelector bool
}

func (q *Queries) UpdateUserSettings(ctx context.Context, arg UpdateUserSettingsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSettings, arg.ID, arg.ShowAiModelSelector)
	return err
}
