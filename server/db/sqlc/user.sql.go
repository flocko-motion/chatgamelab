// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const acceptTargetedInvite = `-- name: AcceptTargetedInvite :exec
UPDATE user_role_invite SET
  status = 'accepted',
  accepted_at = now(),
  accepted_by = $2,
  modified_at = now()
WHERE id = $1
`

type AcceptTargetedInviteParams struct {
	ID         uuid.UUID
	AcceptedBy uuid.NullUUID
}

func (q *Queries) AcceptTargetedInvite(ctx context.Context, arg AcceptTargetedInviteParams) error {
	_, err := q.db.ExecContext(ctx, acceptTargetedInvite, arg.ID, arg.AcceptedBy)
	return err
}

const createApiKey = `-- name: CreateApiKey :one

INSERT INTO api_key (
  id, created_by,
  created_at, modified_by, modified_at,
  user_id, name, platform, key
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, $6, $7, $8
)
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key
`

type CreateApiKeyParams struct {
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	Name       string
	Platform   string
	Key        string
}

// api_key --------------------------------------------------------------
func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createApiKey,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.UserID,
		arg.Name,
		arg.Platform,
		arg.Key,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const createOpenInvite = `-- name: CreateOpenInvite :one
INSERT INTO user_role_invite (
  id, created_by, created_at, modified_by, modified_at,
  institution_id, role, workshop_id,
  invite_token, max_uses, expires_at,
  status
) VALUES (
  gen_random_uuid(), $1, now(), $1, now(),
  $2, $3, $4,
  $5, $6, $7,
  'pending'
)
RETURNING id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by
`

type CreateOpenInviteParams struct {
	CreatedBy     uuid.NullUUID
	InstitutionID uuid.UUID
	Role          string
	WorkshopID    uuid.NullUUID
	InviteToken   sql.NullString
	MaxUses       sql.NullInt32
	ExpiresAt     sql.NullTime
}

func (q *Queries) CreateOpenInvite(ctx context.Context, arg CreateOpenInviteParams) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, createOpenInvite,
		arg.CreatedBy,
		arg.InstitutionID,
		arg.Role,
		arg.WorkshopID,
		arg.InviteToken,
		arg.MaxUses,
		arg.ExpiresAt,
	)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const createTargetedInvite = `-- name: CreateTargetedInvite :one

INSERT INTO user_role_invite (
  id, created_by, created_at, modified_by, modified_at,
  institution_id, role, workshop_id,
  invited_user_id, invited_email,
  invite_token,
  status
) VALUES (
  gen_random_uuid(), $1, now(), $1, now(),
  $2, $3, $4,
  $5, $6,
  $7,
  'pending'
)
RETURNING id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by
`

type CreateTargetedInviteParams struct {
	CreatedBy     uuid.NullUUID
	InstitutionID uuid.UUID
	Role          string
	WorkshopID    uuid.NullUUID
	InvitedUserID uuid.NullUUID
	InvitedEmail  sql.NullString
	InviteToken   sql.NullString
}

// user_role_invite -------------------------------------------------------------
func (q *Queries) CreateTargetedInvite(ctx context.Context, arg CreateTargetedInviteParams) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, createTargetedInvite,
		arg.CreatedBy,
		arg.InstitutionID,
		arg.Role,
		arg.WorkshopID,
		arg.InvitedUserID,
		arg.InvitedEmail,
		arg.InviteToken,
	)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO app_user (id, name, email, auth0_id)
VALUES (gen_random_uuid(), $1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

// app_user -------------------------------------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUserRole = `-- name: CreateUserRole :one
INSERT INTO user_role (id, user_id, role, institution_id, workshop_id)
VALUES (gen_random_uuid(), $1, $2, $3, $4)
RETURNING id
`

type CreateUserRoleParams struct {
	UserID        uuid.UUID
	Role          sql.NullString
	InstitutionID uuid.NullUUID
	WorkshopID    uuid.NullUUID
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, createUserRole,
		arg.UserID,
		arg.Role,
		arg.InstitutionID,
		arg.WorkshopID,
	)
	var id uuid.NullUUID
	err := row.Scan(&id)
	return id, err
}

const createUserWithID = `-- name: CreateUserWithID :one
INSERT INTO app_user (id, name, email, auth0_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
RETURNING id
`

type CreateUserWithIDParams struct {
	ID      uuid.UUID
	Name    string
	Email   sql.NullString
	Auth0ID sql.NullString
}

func (q *Queries) CreateUserWithID(ctx context.Context, arg CreateUserWithIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUserWithID,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Auth0ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM api_key WHERE id = $1 AND user_id = $2
`

type DeleteApiKeyParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteApiKey(ctx context.Context, arg DeleteApiKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteApiKey, arg.ID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE app_user
SET
  deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec

DELETE FROM user_role WHERE user_id = $1
`

// user_role -------------------------------------------------------------
func (q *Queries) DeleteUserRoles(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserRoles, userID)
	return err
}

const getApiKeyByID = `-- name: GetApiKeyByID :one
SELECT id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key FROM api_key WHERE id = $1
`

func (q *Queries) GetApiKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const getInviteByID = `-- name: GetInviteByID :one
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite WHERE id = $1
`

func (q *Queries) GetInviteByID(ctx context.Context, id uuid.UUID) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByID, id)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInviteByToken = `-- name: GetInviteByToken :one
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite WHERE invite_token = $1
`

func (q *Queries) GetInviteByToken(ctx context.Context, inviteToken sql.NullString) (UserRoleInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByToken, inviteToken)
	var i UserRoleInvite
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.InstitutionID,
		&i.Role,
		&i.WorkshopID,
		&i.InvitedUserID,
		&i.InvitedEmail,
		&i.InviteToken,
		&i.MaxUses,
		&i.UsesCount,
		&i.ExpiresAt,
		&i.Status,
		&i.DeletedAt,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInvites = `-- name: GetInvites :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite 
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetInvites(ctx context.Context) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitesByUser = `-- name: GetInvitesByUser :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite 
WHERE (invited_user_id = $1 OR invited_email = (SELECT email FROM app_user WHERE id = $1))
  AND deleted_at IS NULL
  AND status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByUser(ctx context.Context, invitedUserID uuid.NullUUID) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvitesByUser, invitedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitesByWorkshop = `-- name: GetInvitesByWorkshop :many
SELECT id, created_by, created_at, modified_by, modified_at, institution_id, role, workshop_id, invited_user_id, invited_email, invite_token, max_uses, uses_count, expires_at, status, deleted_at, accepted_at, accepted_by FROM user_role_invite 
WHERE workshop_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetInvitesByWorkshop(ctx context.Context, workshopID uuid.NullUUID) ([]UserRoleInvite, error) {
	rows, err := q.db.QueryContext(ctx, getInvitesByWorkshop, workshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRoleInvite
	for rows.Next() {
		var i UserRoleInvite
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.InstitutionID,
			&i.Role,
			&i.WorkshopID,
			&i.InvitedUserID,
			&i.InvitedEmail,
			&i.InviteToken,
			&i.MaxUses,
			&i.UsesCount,
			&i.ExpiresAt,
			&i.Status,
			&i.DeletedAt,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserApiKeys = `-- name: GetUserApiKeys :many
SELECT
  k.id,
  k.created_by,
  k.created_at,
  k.modified_by,
  k.modified_at,
  k.user_id,
  u.name AS user_name,
  k.name,
  k.platform,
  k.key
FROM api_key k
JOIN app_user u ON u.id = k.user_id
WHERE k.user_id = $1
`

type GetUserApiKeysRow struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	UserID     uuid.UUID
	UserName   string
	Name       string
	Platform   string
	Key        string
}

func (q *Queries) GetUserApiKeys(ctx context.Context, userID uuid.UUID) ([]GetUserApiKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserApiKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserApiKeysRow
	for rows.Next() {
		var i GetUserApiKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.UserID,
			&i.UserName,
			&i.Name,
			&i.Platform,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, email, deleted_at, auth0_id, default_api_key_share_id FROM app_user WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.DefaultApiKeyShareID,
	)
	return i, err
}

const getUserDefaultApiKeyShare = `-- name: GetUserDefaultApiKeyShare :one
SELECT default_api_key_share_id FROM app_user WHERE id = $1
`

func (q *Queries) GetUserDefaultApiKeyShare(ctx context.Context, id uuid.UUID) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getUserDefaultApiKeyShare, id)
	var default_api_key_share_id uuid.NullUUID
	err := row.Scan(&default_api_key_share_id)
	return default_api_key_share_id, err
}

const getUserDetailsByID = `-- name: GetUserDetailsByID :one
SELECT
  u.id,
  u.created_by,
  u.created_at,
  u.modified_by,
  u.modified_at,
  u.name,
  u.email,
  u.deleted_at,
  u.auth0_id,
  u.default_api_key_share_id,
  r.id           AS role_id,
  r.role         AS role,
  r.institution_id,
  i.name         AS institution_name,
  r.workshop_id,
  w.name         AS workshop_name
FROM app_user u
LEFT JOIN LATERAL (
  SELECT ur.id, ur.created_by, ur.created_at, ur.modified_by, ur.modified_at, ur.user_id, ur.role, ur.institution_id, ur.workshop_id
  FROM user_role ur
  WHERE ur.user_id = u.id
  ORDER BY ur.created_at DESC
  LIMIT 1
) r ON TRUE
LEFT JOIN institution i
  ON i.id = r.institution_id
LEFT JOIN workshop w
  ON w.id = r.workshop_id
WHERE u.id = $1
`

type GetUserDetailsByIDRow struct {
	ID                   uuid.UUID
	CreatedBy            uuid.NullUUID
	CreatedAt            time.Time
	ModifiedBy           uuid.NullUUID
	ModifiedAt           time.Time
	Name                 string
	Email                sql.NullString
	DeletedAt            sql.NullTime
	Auth0ID              sql.NullString
	DefaultApiKeyShareID uuid.NullUUID
	RoleID               uuid.NullUUID
	Role                 sql.NullString
	InstitutionID        uuid.NullUUID
	InstitutionName      sql.NullString
	WorkshopID           uuid.NullUUID
	WorkshopName         sql.NullString
}

func (q *Queries) GetUserDetailsByID(ctx context.Context, id uuid.UUID) (GetUserDetailsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetailsByID, id)
	var i GetUserDetailsByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Email,
		&i.DeletedAt,
		&i.Auth0ID,
		&i.DefaultApiKeyShareID,
		&i.RoleID,
		&i.Role,
		&i.InstitutionID,
		&i.InstitutionName,
		&i.WorkshopID,
		&i.WorkshopName,
	)
	return i, err
}

const getUserIDByAuth0ID = `-- name: GetUserIDByAuth0ID :one
SELECT id FROM app_user WHERE auth0_id = $1
`

func (q *Queries) GetUserIDByAuth0ID(ctx context.Context, auth0ID sql.NullString) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserIDByAuth0ID, auth0ID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const hasWorkshopRole = `-- name: HasWorkshopRole :one
SELECT EXISTS(
    SELECT 1 FROM user_role 
    WHERE user_id = $1 AND workshop_id = $2
) AS has_role
`

type HasWorkshopRoleParams struct {
	UserID     uuid.UUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) HasWorkshopRole(ctx context.Context, arg HasWorkshopRoleParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasWorkshopRole, arg.UserID, arg.WorkshopID)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}

const incrementInviteUses = `-- name: IncrementInviteUses :exec
UPDATE user_role_invite SET
  uses_count = uses_count + 1,
  modified_at = now()
WHERE id = $1
`

func (q *Queries) IncrementInviteUses(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementInviteUses, id)
	return err
}

const isEmailTakenByOther = `-- name: IsEmailTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE email = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsEmailTakenByOtherParams struct {
	Email sql.NullString
	ID    uuid.UUID
}

func (q *Queries) IsEmailTakenByOther(ctx context.Context, arg IsEmailTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isEmailTakenByOther, arg.Email, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTaken = `-- name: IsNameTaken :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND deleted_at IS NULL) AS taken
`

func (q *Queries) IsNameTaken(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTaken, name)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const isNameTakenByOther = `-- name: IsNameTakenByOther :one
SELECT EXISTS(SELECT 1 FROM app_user WHERE name = $1 AND id != $2 AND deleted_at IS NULL) AS taken
`

type IsNameTakenByOtherParams struct {
	Name string
	ID   uuid.UUID
}

func (q *Queries) IsNameTakenByOther(ctx context.Context, arg IsNameTakenByOtherParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isNameTakenByOther, arg.Name, arg.ID)
	var taken bool
	err := row.Scan(&taken)
	return taken, err
}

const setUserDefaultApiKeyShare = `-- name: SetUserDefaultApiKeyShare :exec

UPDATE app_user SET
  default_api_key_share_id = $2,
  modified_at = now()
WHERE id = $1
`

type SetUserDefaultApiKeyShareParams struct {
	ID                   uuid.UUID
	DefaultApiKeyShareID uuid.NullUUID
}

// GetApiKeySharesByUserID is now in api_key.sql using the unified api_key_share table
func (q *Queries) SetUserDefaultApiKeyShare(ctx context.Context, arg SetUserDefaultApiKeyShareParams) error {
	_, err := q.db.ExecContext(ctx, setUserDefaultApiKeyShare, arg.ID, arg.DefaultApiKeyShareID)
	return err
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE api_key SET
  modified_by = $2,
  modified_at = $3,
  name = $4
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, user_id, name, platform, key
`

type UpdateApiKeyParams struct {
	ID         uuid.UUID
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	Name       string
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKey,
		arg.ID,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.UserID,
		&i.Name,
		&i.Platform,
		&i.Key,
	)
	return i, err
}

const updateInviteStatus = `-- name: UpdateInviteStatus :exec
UPDATE user_role_invite SET
  status = $2,
  modified_at = now()
WHERE id = $1
`

type UpdateInviteStatusParams struct {
	ID     uuid.UUID
	Status string
}

func (q *Queries) UpdateInviteStatus(ctx context.Context, arg UpdateInviteStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateInviteStatus, arg.ID, arg.Status)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE app_user SET
  name = $2,
  email = $3,
  modified_at = now()
WHERE id = $1
`

type UpdateUserParams struct {
	ID    uuid.UUID
	Name  string
	Email sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.ID, arg.Name, arg.Email)
	return err
}
