// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const clearGameSessionApiKeyByID = `-- name: ClearGameSessionApiKeyByID :exec
UPDATE game_session SET api_key_id = NULL, modified_at = now() WHERE id = $1
`

func (q *Queries) ClearGameSessionApiKeyByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearGameSessionApiKeyByID, id)
	return err
}

const clearPrivateShareGameIDByGameID = `-- name: ClearPrivateShareGameIDByGameID :exec
UPDATE app_user SET private_share_game_id = NULL WHERE private_share_game_id = $1
`

func (q *Queries) ClearPrivateShareGameIDByGameID(ctx context.Context, privateShareGameID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, clearPrivateShareGameIDByGameID, privateShareGameID)
	return err
}

const createGame = `-- name: CreateGame :one



INSERT INTO game (
  id, created_by,
  created_at, modified_by, modified_at,
  name, description, icon,
  workshop_id,
  public, public_sponsored_api_key_share_id,
  private_share_hash, private_sponsored_api_key_share_id, private_share_remaining,
  system_message_scenario, system_message_game_start,
  image_style, css, status_fields,
  theme,
  first_message, first_status, first_image,
  originally_created_by, play_count, clone_count
) VALUES (
  $1, $2,
  $3, $4, $5,
  $6, $7, $8,
  $9,
  $10, $11,
  $12, $13, $14,
  $15, $16,
  $17, $18, $19,
  $20,
  $21, $22, $23,
  $24, $25, $26
)
RETURNING id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at
`

type CreateGameParams struct {
	ID                            uuid.UUID
	CreatedBy                     uuid.NullUUID
	CreatedAt                     time.Time
	ModifiedBy                    uuid.NullUUID
	ModifiedAt                    time.Time
	Name                          string
	Description                   string
	Icon                          []byte
	WorkshopID                    uuid.NullUUID
	Public                        bool
	PublicSponsoredApiKeyShareID  uuid.NullUUID
	PrivateShareHash              sql.NullString
	PrivateSponsoredApiKeyShareID uuid.NullUUID
	PrivateShareRemaining         sql.NullInt32
	SystemMessageScenario         string
	SystemMessageGameStart        string
	ImageStyle                    string
	Css                           string
	StatusFields                  string
	Theme                         pqtype.NullRawMessage
	FirstMessage                  sql.NullString
	FirstStatus                   sql.NullString
	FirstImage                    []byte
	OriginallyCreatedBy           uuid.NullUUID
	PlayCount                     int32
	CloneCount                    int32
}

// Basic CRUD queries for core entities
// Exactly four per table: create, read by id, update by id, delete by id.
// game -----------------------------------------------------------------
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.WorkshopID,
		arg.Public,
		arg.PublicSponsoredApiKeyShareID,
		arg.PrivateShareHash,
		arg.PrivateSponsoredApiKeyShareID,
		arg.PrivateShareRemaining,
		arg.SystemMessageScenario,
		arg.SystemMessageGameStart,
		arg.ImageStyle,
		arg.Css,
		arg.StatusFields,
		arg.Theme,
		arg.FirstMessage,
		arg.FirstStatus,
		arg.FirstImage,
		arg.OriginallyCreatedBy,
		arg.PlayCount,
		arg.CloneCount,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.WorkshopID,
		&i.Public,
		&i.PublicSponsoredApiKeyShareID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyShareID,
		&i.PrivateShareRemaining,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.Theme,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
		&i.OriginallyCreatedBy,
		&i.PlayCount,
		&i.CloneCount,
		&i.DeletedAt,
	)
	return i, err
}

const createGameSession = `-- name: CreateGameSession :one

INSERT INTO game_session (
  id, created_by,
  created_at, modified_by, modified_at,
  game_id, user_id, workshop_id, api_key_id,
  ai_platform, ai_model, ai_session,
  image_style, language, status_fields, theme
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, $6, $7, $8,
  $9, $10, $11,
  $12, $13, $14, $15
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at
`

type CreateGameSessionParams struct {
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	WorkshopID   uuid.NullUUID
	ApiKeyID     uuid.NullUUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	Language     string
	StatusFields string
	Theme        pqtype.NullRawMessage
}

// game_session ---------------------------------------------------------
func (q *Queries) CreateGameSession(ctx context.Context, arg CreateGameSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, createGameSession,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.UserID,
		arg.WorkshopID,
		arg.ApiKeyID,
		arg.AiPlatform,
		arg.AiModel,
		arg.AiSession,
		arg.ImageStyle,
		arg.Language,
		arg.StatusFields,
		arg.Theme,
	)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.WorkshopID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.Language,
		&i.StatusFields,
		&i.Theme,
		&i.IsOrganisationUnverified,
		&i.DeletedAt,
	)
	return i, err
}

const createGameSessionMessage = `-- name: CreateGameSessionMessage :one

INSERT INTO game_session_message (
  id, created_by,
  created_at, modified_by, modified_at,
  game_session_id, seq,
  type, message,
  status, image_prompt, image,
  has_image, has_audio
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, (SELECT COALESCE(MAX(seq), 0) + 1 FROM game_session_message WHERE game_session_id = $5),
  $6, $7,
  $8, $9, $10,
  $11, $12
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at
`

type CreateGameSessionMessageParams struct {
	CreatedBy     uuid.NullUUID
	CreatedAt     time.Time
	ModifiedBy    uuid.NullUUID
	ModifiedAt    time.Time
	GameSessionID uuid.UUID
	Type          string
	Message       string
	Status        sql.NullString
	ImagePrompt   sql.NullString
	Image         []byte
	HasImage      bool
	HasAudio      bool
}

// game_session_message -------------------------------------------------
func (q *Queries) CreateGameSessionMessage(ctx context.Context, arg CreateGameSessionMessageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, createGameSessionMessage,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameSessionID,
		arg.Type,
		arg.Message,
		arg.Status,
		arg.ImagePrompt,
		arg.Image,
		arg.HasImage,
		arg.HasAudio,
	)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const createGameTag = `-- name: CreateGameTag :one

INSERT INTO game_tag (
  id, created_by,
  created_at, modified_by, modified_at,
  game_id, tag
) VALUES (
  $1, $2,
  $3, $4, $5,
  $6, $7
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, tag
`

type CreateGameTagParams struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	GameID     uuid.UUID
	Tag        string
}

// game_tag -------------------------------------------------------------
func (q *Queries) CreateGameTag(ctx context.Context, arg CreateGameTagParams) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, createGameTag,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.Tag,
	)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}

const decrementPrivateShareRemaining = `-- name: DecrementPrivateShareRemaining :one
UPDATE game SET private_share_remaining = CASE
  WHEN private_share_remaining IS NULL THEN NULL
  ELSE private_share_remaining - 1
END, modified_at = now()
WHERE id = $1 AND (private_share_remaining IS NULL OR private_share_remaining > 0)
RETURNING id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at
`

// Atomically decrements the remaining counter. Returns the game if successful.
// Succeeds when: remaining is NULL (unlimited) or remaining > 0.
func (q *Queries) DecrementPrivateShareRemaining(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, decrementPrivateShareRemaining, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.WorkshopID,
		&i.Public,
		&i.PublicSponsoredApiKeyShareID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyShareID,
		&i.PrivateShareRemaining,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.Theme,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
		&i.OriginallyCreatedBy,
		&i.PlayCount,
		&i.CloneCount,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAllUserSessions = `-- name: DeleteAllUserSessions :exec
DELETE FROM game_session WHERE user_id = $1
`

func (q *Queries) DeleteAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAllUserSessions, userID)
	return err
}

const deleteEmptyGameSession = `-- name: DeleteEmptyGameSession :exec
DELETE FROM game_session gs WHERE gs.id = $1
`

func (q *Queries) DeleteEmptyGameSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEmptyGameSession, id)
	return err
}

const deleteFavouritesByGameID = `-- name: DeleteFavouritesByGameID :exec
DELETE FROM user_favourite_game WHERE game_id = $1
`

func (q *Queries) DeleteFavouritesByGameID(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteFavouritesByGameID, gameID)
	return err
}

const deleteGameSession = `-- name: DeleteGameSession :exec
DELETE FROM game_session WHERE id = $1
`

func (q *Queries) DeleteGameSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSession, id)
	return err
}

const deleteGameSessionMessage = `-- name: DeleteGameSessionMessage :exec
DELETE FROM game_session_message WHERE id = $1
`

func (q *Queries) DeleteGameSessionMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessage, id)
	return err
}

const deleteGameSessionMessagesByGameID = `-- name: DeleteGameSessionMessagesByGameID :exec
DELETE FROM game_session_message WHERE game_session_id IN (
  SELECT id FROM game_session WHERE game_id = $1
)
`

func (q *Queries) DeleteGameSessionMessagesByGameID(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessagesByGameID, gameID)
	return err
}

const deleteGameSessionMessagesBySessionID = `-- name: DeleteGameSessionMessagesBySessionID :exec
DELETE FROM game_session_message WHERE game_session_id = $1
`

func (q *Queries) DeleteGameSessionMessagesBySessionID(ctx context.Context, gameSessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessagesBySessionID, gameSessionID)
	return err
}

const deleteGameSessionMessagesByUserID = `-- name: DeleteGameSessionMessagesByUserID :exec
DELETE FROM game_session_message WHERE game_session_id IN (
  SELECT id FROM game_session WHERE user_id = $1
)
`

func (q *Queries) DeleteGameSessionMessagesByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessagesByUserID, userID)
	return err
}

const deleteGameSessionsByGameID = `-- name: DeleteGameSessionsByGameID :exec
DELETE FROM game_session WHERE game_id = $1
`

func (q *Queries) DeleteGameSessionsByGameID(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionsByGameID, gameID)
	return err
}

const deleteGameTag = `-- name: DeleteGameTag :exec
DELETE FROM game_tag WHERE id = $1
`

func (q *Queries) DeleteGameTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameTag, id)
	return err
}

const deleteGameTagsByGameID = `-- name: DeleteGameTagsByGameID :exec
DELETE FROM game_tag WHERE game_id = $1
`

func (q *Queries) DeleteGameTagsByGameID(ctx context.Context, gameID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameTagsByGameID, gameID)
	return err
}

const deleteNewlyCreatedGameSession = `-- name: DeleteNewlyCreatedGameSession :exec
DELETE FROM game_session_message WHERE game_session_id = $1
`

// Deletes a session and its messages if it has at most 1 message (the streaming placeholder)
// Used to clean up sessions that failed during initial action before any real content was generated
func (q *Queries) DeleteNewlyCreatedGameSession(ctx context.Context, gameSessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteNewlyCreatedGameSession, gameSessionID)
	return err
}

const deleteUserGameSessions = `-- name: DeleteUserGameSessions :exec
DELETE FROM game_session WHERE user_id = $1 AND game_id = $2
`

type DeleteUserGameSessionsParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
}

func (q *Queries) DeleteUserGameSessions(ctx context.Context, arg DeleteUserGameSessionsParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserGameSessions, arg.UserID, arg.GameID)
	return err
}

const getAllGameSessionMessages = `-- name: GetAllGameSessionMessages :many
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at FROM game_session_message WHERE game_session_id = $1 ORDER BY seq ASC
`

func (q *Queries) GetAllGameSessionMessages(ctx context.Context, gameSessionID uuid.UUID) ([]GameSessionMessage, error) {
	rows, err := q.db.QueryContext(ctx, getAllGameSessionMessages, gameSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameSessionMessage
	for rows.Next() {
		var i GameSessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameSessionID,
			&i.Seq,
			&i.Type,
			&i.Message,
			&i.Status,
			&i.ImagePrompt,
			&i.Image,
			&i.Audio,
			&i.HasImage,
			&i.HasAudio,
			&i.PromptStatusUpdate,
			&i.PromptResponseSchema,
			&i.PromptImageGeneration,
			&i.PromptExpandStory,
			&i.ResponseRaw,
			&i.TokenUsage,
			&i.UrlAnalytics,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameByID = `-- name: GetGameByID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.WorkshopID,
		&i.Public,
		&i.PublicSponsoredApiKeyShareID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyShareID,
		&i.PrivateShareRemaining,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.Theme,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
		&i.OriginallyCreatedBy,
		&i.PlayCount,
		&i.CloneCount,
		&i.DeletedAt,
	)
	return i, err
}

const getGameByPrivateShareHash = `-- name: GetGameByPrivateShareHash :one
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND private_share_hash = $1
`

func (q *Queries) GetGameByPrivateShareHash(ctx context.Context, privateShareHash sql.NullString) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByPrivateShareHash, privateShareHash)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.WorkshopID,
		&i.Public,
		&i.PublicSponsoredApiKeyShareID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyShareID,
		&i.PrivateShareRemaining,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.Theme,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
		&i.OriginallyCreatedBy,
		&i.PlayCount,
		&i.CloneCount,
		&i.DeletedAt,
	)
	return i, err
}

const getGameIDsByCreator = `-- name: GetGameIDsByCreator :many

SELECT id FROM game WHERE created_by = $1
`

// User deletion: game cleanup queries
func (q *Queries) GetGameIDsByCreator(ctx context.Context, createdBy uuid.NullUUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getGameIDsByCreator, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameIDsVisibleToUser = `-- name: GetGameIDsVisibleToUser :many
SELECT id FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2)
`

type GetGameIDsVisibleToUserParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGameIDsVisibleToUser(ctx context.Context, arg GetGameIDsVisibleToUserParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getGameIDsVisibleToUser, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionByID = `-- name: GetGameSessionByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at FROM game_session WHERE id = $1
`

func (q *Queries) GetGameSessionByID(ctx context.Context, id uuid.UUID) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, getGameSessionByID, id)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.WorkshopID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.Language,
		&i.StatusFields,
		&i.Theme,
		&i.IsOrganisationUnverified,
		&i.DeletedAt,
	)
	return i, err
}

const getGameSessionMessageAudioByID = `-- name: GetGameSessionMessageAudioByID :one
SELECT id, audio FROM game_session_message WHERE id = $1
`

type GetGameSessionMessageAudioByIDRow struct {
	ID    uuid.UUID
	Audio []byte
}

func (q *Queries) GetGameSessionMessageAudioByID(ctx context.Context, id uuid.UUID) (GetGameSessionMessageAudioByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getGameSessionMessageAudioByID, id)
	var i GetGameSessionMessageAudioByIDRow
	err := row.Scan(&i.ID, &i.Audio)
	return i, err
}

const getGameSessionMessageByID = `-- name: GetGameSessionMessageByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at FROM game_session_message WHERE id = $1
`

func (q *Queries) GetGameSessionMessageByID(ctx context.Context, id uuid.UUID) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, getGameSessionMessageByID, id)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const getGameSessionsByGameID = `-- name: GetGameSessionsByGameID :many
SELECT id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at FROM game_session WHERE game_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetGameSessionsByGameID(ctx context.Context, gameID uuid.UUID) ([]GameSession, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameSession
	for rows.Next() {
		var i GameSession
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserID = `-- name: GetGameSessionsByUserID :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1
ORDER BY gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) GetGameSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDRow
	for rows.Next() {
		var i GetGameSessionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserIDSortByGame = `-- name: GetGameSessionsByUserIDSortByGame :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1
ORDER BY LOWER(g.name) ASC, gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDSortByGameRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) GetGameSessionsByUserIDSortByGame(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDSortByGameRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserIDSortByGame, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDSortByGameRow
	for rows.Next() {
		var i GetGameSessionsByUserIDSortByGameRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserIDSortByModel = `-- name: GetGameSessionsByUserIDSortByModel :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1
ORDER BY gs.ai_model ASC, gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDSortByModelRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) GetGameSessionsByUserIDSortByModel(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDSortByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserIDSortByModel, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDSortByModelRow
	for rows.Next() {
		var i GetGameSessionsByUserIDSortByModelRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameTagByID = `-- name: GetGameTagByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_id, tag FROM game_tag WHERE id = $1
`

func (q *Queries) GetGameTagByID(ctx context.Context, id uuid.UUID) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, getGameTagByID, id)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}

const getGameTagsByGameID = `-- name: GetGameTagsByGameID :many
SELECT id, created_by, created_at, modified_by, modified_at, game_id, tag FROM game_tag WHERE game_id = $1
`

func (q *Queries) GetGameTagsByGameID(ctx context.Context, gameID uuid.UUID) ([]GameTag, error) {
	rows, err := q.db.QueryContext(ctx, getGameTagsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameTag
	for rows.Next() {
		var i GameTag
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUser = `-- name: GetGamesVisibleToUser :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY created_at DESC
`

type GetGamesVisibleToUserParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUser(ctx context.Context, arg GetGamesVisibleToUserParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUser, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByCreatedAt = `-- name: GetGamesVisibleToUserSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY created_at ASC
`

type GetGamesVisibleToUserSortedByCreatedAtParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUserSortedByCreatedAt(ctx context.Context, arg GetGamesVisibleToUserSortedByCreatedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByCreatedAt, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByCreator = `-- name: GetGamesVisibleToUserSortedByCreator :many
SELECT g.id, g.created_by, g.created_at, g.modified_by, g.modified_at, g.name, g.description, g.icon, g.workshop_id, g.public, g.public_sponsored_api_key_share_id, g.private_share_hash, g.private_sponsored_api_key_share_id, g.private_share_remaining, g.system_message_scenario, g.system_message_game_start, g.image_style, g.css, g.status_fields, g.theme, g.first_message, g.first_status, g.first_image, g.originally_created_by, g.play_count, g.clone_count, g.deleted_at FROM game g LEFT JOIN app_user u ON g.created_by = u.id WHERE g.deleted_at IS NULL AND (g.created_by = $1 OR g.public = true) ORDER BY LOWER(COALESCE(u.name, '')) ASC
`

// Creator sorting requires joining with user table
func (q *Queries) GetGamesVisibleToUserSortedByCreator(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByCreator, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByCreatorDesc = `-- name: GetGamesVisibleToUserSortedByCreatorDesc :many
SELECT g.id, g.created_by, g.created_at, g.modified_by, g.modified_at, g.name, g.description, g.icon, g.workshop_id, g.public, g.public_sponsored_api_key_share_id, g.private_share_hash, g.private_sponsored_api_key_share_id, g.private_share_remaining, g.system_message_scenario, g.system_message_game_start, g.image_style, g.css, g.status_fields, g.theme, g.first_message, g.first_status, g.first_image, g.originally_created_by, g.play_count, g.clone_count, g.deleted_at FROM game g LEFT JOIN app_user u ON g.created_by = u.id WHERE g.deleted_at IS NULL AND (g.created_by = $1 OR g.public = true) ORDER BY LOWER(COALESCE(u.name, '')) DESC
`

func (q *Queries) GetGamesVisibleToUserSortedByCreatorDesc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByCreatorDesc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByModifiedAt = `-- name: GetGamesVisibleToUserSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY modified_at DESC
`

type GetGamesVisibleToUserSortedByModifiedAtParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUserSortedByModifiedAt(ctx context.Context, arg GetGamesVisibleToUserSortedByModifiedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByModifiedAt, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByModifiedAtAsc = `-- name: GetGamesVisibleToUserSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY modified_at ASC
`

type GetGamesVisibleToUserSortedByModifiedAtAscParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUserSortedByModifiedAtAsc(ctx context.Context, arg GetGamesVisibleToUserSortedByModifiedAtAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByModifiedAtAsc, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByName = `-- name: GetGamesVisibleToUserSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY LOWER(name) ASC
`

type GetGamesVisibleToUserSortedByNameParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUserSortedByName(ctx context.Context, arg GetGamesVisibleToUserSortedByNameParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByName, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByNameDesc = `-- name: GetGamesVisibleToUserSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) ORDER BY LOWER(name) DESC
`

type GetGamesVisibleToUserSortedByNameDescParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
}

func (q *Queries) GetGamesVisibleToUserSortedByNameDesc(ctx context.Context, arg GetGamesVisibleToUserSortedByNameDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByNameDesc, arg.CreatedBy, arg.WorkshopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByPlayCount = `-- name: GetGamesVisibleToUserSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true) ORDER BY play_count DESC
`

// Games visible to user with additional sort options
func (q *Queries) GetGamesVisibleToUserSortedByPlayCount(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByPlayCount, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByPlayCountAsc = `-- name: GetGamesVisibleToUserSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true) ORDER BY play_count ASC
`

func (q *Queries) GetGamesVisibleToUserSortedByPlayCountAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByPlayCountAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGameSessionMessage = `-- name: GetLatestGameSessionMessage :one
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at FROM game_session_message WHERE game_session_id = $1 ORDER BY seq DESC LIMIT 1
`

func (q *Queries) GetLatestGameSessionMessage(ctx context.Context, gameSessionID uuid.UUID) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, getLatestGameSessionMessage, gameSessionID)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const getOwnGames = `-- name: GetOwnGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY created_at DESC
`

// Own games (created by user) queries
func (q *Queries) GetOwnGames(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGames, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByCreatedAt = `-- name: GetOwnGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY created_at ASC
`

func (q *Queries) GetOwnGamesSortedByCreatedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByCreatedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByModifiedAt = `-- name: GetOwnGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY modified_at DESC
`

func (q *Queries) GetOwnGamesSortedByModifiedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByModifiedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByModifiedAtAsc = `-- name: GetOwnGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY modified_at ASC
`

func (q *Queries) GetOwnGamesSortedByModifiedAtAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByModifiedAtAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByName = `-- name: GetOwnGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY LOWER(name) ASC
`

func (q *Queries) GetOwnGamesSortedByName(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByName, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByNameDesc = `-- name: GetOwnGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY LOWER(name) DESC
`

func (q *Queries) GetOwnGamesSortedByNameDesc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByNameDesc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByPlayCount = `-- name: GetOwnGamesSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY play_count DESC
`

func (q *Queries) GetOwnGamesSortedByPlayCount(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByPlayCount, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByPlayCountAsc = `-- name: GetOwnGamesSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY play_count ASC
`

func (q *Queries) GetOwnGamesSortedByPlayCountAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByPlayCountAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByVisibility = `-- name: GetOwnGamesSortedByVisibility :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY public DESC, modified_at DESC
`

func (q *Queries) GetOwnGamesSortedByVisibility(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByVisibility, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByVisibilityAsc = `-- name: GetOwnGamesSortedByVisibilityAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 ORDER BY public ASC, modified_at DESC
`

func (q *Queries) GetOwnGamesSortedByVisibilityAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByVisibilityAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGames = `-- name: GetPublicGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY created_at DESC
`

func (q *Queries) GetPublicGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByCreatedAt = `-- name: GetPublicGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY created_at ASC
`

func (q *Queries) GetPublicGamesSortedByCreatedAt(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByModifiedAt = `-- name: GetPublicGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY modified_at DESC
`

func (q *Queries) GetPublicGamesSortedByModifiedAt(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByModifiedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByModifiedAtAsc = `-- name: GetPublicGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY modified_at ASC
`

func (q *Queries) GetPublicGamesSortedByModifiedAtAsc(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByModifiedAtAsc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByName = `-- name: GetPublicGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY LOWER(name) ASC
`

func (q *Queries) GetPublicGamesSortedByName(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByNameDesc = `-- name: GetPublicGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY LOWER(name) DESC
`

func (q *Queries) GetPublicGamesSortedByNameDesc(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByNameDesc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByPlayCount = `-- name: GetPublicGamesSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY play_count DESC
`

func (q *Queries) GetPublicGamesSortedByPlayCount(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByPlayCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByPlayCountAsc = `-- name: GetPublicGamesSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true ORDER BY play_count ASC
`

func (q *Queries) GetPublicGamesSortedByPlayCountAsc(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByPlayCountAsc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionIDsByUserID = `-- name: GetSessionIDsByUserID :many
SELECT id FROM game_session WHERE user_id = $1
`

func (q *Queries) GetSessionIDsByUserID(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getSessionIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteGame = `-- name: HardDeleteGame :exec
DELETE FROM game WHERE id = $1
`

func (q *Queries) HardDeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, hardDeleteGame, id)
	return err
}

const hardDeleteGamesByCreator = `-- name: HardDeleteGamesByCreator :exec
DELETE FROM game WHERE created_by = $1
`

func (q *Queries) HardDeleteGamesByCreator(ctx context.Context, createdBy uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, hardDeleteGamesByCreator, createdBy)
	return err
}

const incrementGameCloneCount = `-- name: IncrementGameCloneCount :exec
UPDATE game SET clone_count = clone_count + 1 WHERE id = $1
`

func (q *Queries) IncrementGameCloneCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementGameCloneCount, id)
	return err
}

const incrementGamePlayCount = `-- name: IncrementGamePlayCount :exec
UPDATE game SET play_count = play_count + 1 WHERE id = $1
`

func (q *Queries) IncrementGamePlayCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementGamePlayCount, id)
	return err
}

const searchGameSessionsByUserID = `-- name: SearchGameSessionsByUserID :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) SearchGameSessionsByUserID(ctx context.Context, arg SearchGameSessionsByUserIDParams) ([]SearchGameSessionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserID, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGameSessionsByUserIDSortByGame = `-- name: SearchGameSessionsByUserIDSortByGame :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY LOWER(g.name) ASC, gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDSortByGameParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDSortByGameRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) SearchGameSessionsByUserIDSortByGame(ctx context.Context, arg SearchGameSessionsByUserIDSortByGameParams) ([]SearchGameSessionsByUserIDSortByGameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserIDSortByGame, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDSortByGameRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDSortByGameRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGameSessionsByUserIDSortByModel = `-- name: SearchGameSessionsByUserIDSortByModel :many
SELECT
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.workshop_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.language, gs.status_fields, gs.theme, gs.is_organisation_unverified, gs.deleted_at,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY gs.ai_model ASC, gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDSortByModelParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDSortByModelRow struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	GameID                   uuid.UUID
	UserID                   uuid.UUID
	WorkshopID               uuid.NullUUID
	ApiKeyID                 uuid.NullUUID
	AiPlatform               string
	AiModel                  string
	AiSession                json.RawMessage
	ImageStyle               string
	Language                 string
	StatusFields             string
	Theme                    pqtype.NullRawMessage
	IsOrganisationUnverified bool
	DeletedAt                sql.NullTime
	GameName                 string
}

func (q *Queries) SearchGameSessionsByUserIDSortByModel(ctx context.Context, arg SearchGameSessionsByUserIDSortByModelParams) ([]SearchGameSessionsByUserIDSortByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserIDSortByModel, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDSortByModelRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDSortByModelRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.WorkshopID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.Language,
			&i.StatusFields,
			&i.Theme,
			&i.IsOrganisationUnverified,
			&i.DeletedAt,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUser = `-- name: SearchGamesVisibleToUser :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY created_at DESC
`

type SearchGamesVisibleToUserParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUser(ctx context.Context, arg SearchGamesVisibleToUserParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUser, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByCreatedAt = `-- name: SearchGamesVisibleToUserSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY created_at ASC
`

type SearchGamesVisibleToUserSortedByCreatedAtParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByCreatedAt(ctx context.Context, arg SearchGamesVisibleToUserSortedByCreatedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByCreatedAt, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByCreator = `-- name: SearchGamesVisibleToUserSortedByCreator :many
SELECT g.id, g.created_by, g.created_at, g.modified_by, g.modified_at, g.name, g.description, g.icon, g.workshop_id, g.public, g.public_sponsored_api_key_share_id, g.private_share_hash, g.private_sponsored_api_key_share_id, g.private_share_remaining, g.system_message_scenario, g.system_message_game_start, g.image_style, g.css, g.status_fields, g.theme, g.first_message, g.first_status, g.first_image, g.originally_created_by, g.play_count, g.clone_count, g.deleted_at FROM game g LEFT JOIN app_user u ON g.created_by = u.id WHERE g.deleted_at IS NULL AND (g.created_by = $1 OR g.public = true) AND LOWER(g.name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(COALESCE(u.name, '')) ASC
`

type SearchGamesVisibleToUserSortedByCreatorParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByCreator(ctx context.Context, arg SearchGamesVisibleToUserSortedByCreatorParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByCreator, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByCreatorDesc = `-- name: SearchGamesVisibleToUserSortedByCreatorDesc :many
SELECT g.id, g.created_by, g.created_at, g.modified_by, g.modified_at, g.name, g.description, g.icon, g.workshop_id, g.public, g.public_sponsored_api_key_share_id, g.private_share_hash, g.private_sponsored_api_key_share_id, g.private_share_remaining, g.system_message_scenario, g.system_message_game_start, g.image_style, g.css, g.status_fields, g.theme, g.first_message, g.first_status, g.first_image, g.originally_created_by, g.play_count, g.clone_count, g.deleted_at FROM game g LEFT JOIN app_user u ON g.created_by = u.id WHERE g.deleted_at IS NULL AND (g.created_by = $1 OR g.public = true) AND LOWER(g.name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(COALESCE(u.name, '')) DESC
`

type SearchGamesVisibleToUserSortedByCreatorDescParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByCreatorDesc(ctx context.Context, arg SearchGamesVisibleToUserSortedByCreatorDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByCreatorDesc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByModifiedAt = `-- name: SearchGamesVisibleToUserSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY modified_at DESC
`

type SearchGamesVisibleToUserSortedByModifiedAtParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByModifiedAt(ctx context.Context, arg SearchGamesVisibleToUserSortedByModifiedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByModifiedAt, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByModifiedAtAsc = `-- name: SearchGamesVisibleToUserSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY modified_at ASC
`

type SearchGamesVisibleToUserSortedByModifiedAtAscParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByModifiedAtAsc(ctx context.Context, arg SearchGamesVisibleToUserSortedByModifiedAtAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByModifiedAtAsc, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByName = `-- name: SearchGamesVisibleToUserSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY LOWER(name) ASC
`

type SearchGamesVisibleToUserSortedByNameParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByName(ctx context.Context, arg SearchGamesVisibleToUserSortedByNameParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByName, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByNameDesc = `-- name: SearchGamesVisibleToUserSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true OR workshop_id = $2) AND LOWER(name) LIKE LOWER('%' || $3 || '%') ORDER BY LOWER(name) DESC
`

type SearchGamesVisibleToUserSortedByNameDescParams struct {
	CreatedBy  uuid.NullUUID
	WorkshopID uuid.NullUUID
	Column3    sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByNameDesc(ctx context.Context, arg SearchGamesVisibleToUserSortedByNameDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByNameDesc, arg.CreatedBy, arg.WorkshopID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByPlayCount = `-- name: SearchGamesVisibleToUserSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY play_count DESC
`

type SearchGamesVisibleToUserSortedByPlayCountParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByPlayCount(ctx context.Context, arg SearchGamesVisibleToUserSortedByPlayCountParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByPlayCount, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByPlayCountAsc = `-- name: SearchGamesVisibleToUserSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY play_count ASC
`

type SearchGamesVisibleToUserSortedByPlayCountAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByPlayCountAsc(ctx context.Context, arg SearchGamesVisibleToUserSortedByPlayCountAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByPlayCountAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGames = `-- name: SearchOwnGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at DESC
`

type SearchOwnGamesParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGames(ctx context.Context, arg SearchOwnGamesParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGames, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByCreatedAt = `-- name: SearchOwnGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at ASC
`

type SearchOwnGamesSortedByCreatedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByCreatedAt(ctx context.Context, arg SearchOwnGamesSortedByCreatedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByCreatedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByModifiedAt = `-- name: SearchOwnGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at DESC
`

type SearchOwnGamesSortedByModifiedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByModifiedAt(ctx context.Context, arg SearchOwnGamesSortedByModifiedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByModifiedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByModifiedAtAsc = `-- name: SearchOwnGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at ASC
`

type SearchOwnGamesSortedByModifiedAtAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByModifiedAtAsc(ctx context.Context, arg SearchOwnGamesSortedByModifiedAtAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByModifiedAtAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByName = `-- name: SearchOwnGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) ASC
`

type SearchOwnGamesSortedByNameParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByName(ctx context.Context, arg SearchOwnGamesSortedByNameParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByName, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByNameDesc = `-- name: SearchOwnGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) DESC
`

type SearchOwnGamesSortedByNameDescParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByNameDesc(ctx context.Context, arg SearchOwnGamesSortedByNameDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByNameDesc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByPlayCount = `-- name: SearchOwnGamesSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY play_count DESC
`

type SearchOwnGamesSortedByPlayCountParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByPlayCount(ctx context.Context, arg SearchOwnGamesSortedByPlayCountParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByPlayCount, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByPlayCountAsc = `-- name: SearchOwnGamesSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY play_count ASC
`

type SearchOwnGamesSortedByPlayCountAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByPlayCountAsc(ctx context.Context, arg SearchOwnGamesSortedByPlayCountAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByPlayCountAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByVisibility = `-- name: SearchOwnGamesSortedByVisibility :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY public DESC, modified_at DESC
`

type SearchOwnGamesSortedByVisibilityParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByVisibility(ctx context.Context, arg SearchOwnGamesSortedByVisibilityParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByVisibility, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByVisibilityAsc = `-- name: SearchOwnGamesSortedByVisibilityAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY public ASC, modified_at DESC
`

type SearchOwnGamesSortedByVisibilityAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByVisibilityAsc(ctx context.Context, arg SearchOwnGamesSortedByVisibilityAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByVisibilityAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGames = `-- name: SearchPublicGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY created_at DESC
`

func (q *Queries) SearchPublicGames(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByCreatedAt = `-- name: SearchPublicGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY created_at ASC
`

func (q *Queries) SearchPublicGamesSortedByCreatedAt(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByCreatedAt, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByModifiedAt = `-- name: SearchPublicGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY modified_at DESC
`

func (q *Queries) SearchPublicGamesSortedByModifiedAt(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByModifiedAt, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByModifiedAtAsc = `-- name: SearchPublicGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY modified_at ASC
`

func (q *Queries) SearchPublicGamesSortedByModifiedAtAsc(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByModifiedAtAsc, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByName = `-- name: SearchPublicGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY LOWER(name) ASC
`

func (q *Queries) SearchPublicGamesSortedByName(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByNameDesc = `-- name: SearchPublicGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY LOWER(name) DESC
`

func (q *Queries) SearchPublicGamesSortedByNameDesc(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByNameDesc, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByPlayCount = `-- name: SearchPublicGamesSortedByPlayCount :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY play_count DESC
`

func (q *Queries) SearchPublicGamesSortedByPlayCount(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByPlayCount, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByPlayCountAsc = `-- name: SearchPublicGamesSortedByPlayCountAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at FROM game WHERE deleted_at IS NULL AND public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY play_count ASC
`

func (q *Queries) SearchPublicGamesSortedByPlayCountAsc(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByPlayCountAsc, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteGame = `-- name: SoftDeleteGame :exec
UPDATE game SET deleted_at = now(), modified_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteGame, id)
	return err
}

const unlinkGamesFromWorkshop = `-- name: UnlinkGamesFromWorkshop :exec
UPDATE game SET workshop_id = NULL WHERE workshop_id = $1
`

func (q *Queries) UnlinkGamesFromWorkshop(ctx context.Context, workshopID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, unlinkGamesFromWorkshop, workshopID)
	return err
}

const updateGame = `-- name: UpdateGame :one
UPDATE game SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  name = $6,
  description = $7,
  icon = $8,
  public = $9,
  public_sponsored_api_key_share_id = $10,
  private_share_hash = $11,
  private_sponsored_api_key_share_id = $12,
  private_share_remaining = $13,
  system_message_scenario = $14,
  system_message_game_start = $15,
  image_style = $16,
  css = $17,
  status_fields = $18,
  theme = $19,
  first_message = $20,
  first_status = $21,
  first_image = $22,
  originally_created_by = $23
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, name, description, icon, workshop_id, public, public_sponsored_api_key_share_id, private_share_hash, private_sponsored_api_key_share_id, private_share_remaining, system_message_scenario, system_message_game_start, image_style, css, status_fields, theme, first_message, first_status, first_image, originally_created_by, play_count, clone_count, deleted_at
`

type UpdateGameParams struct {
	ID                            uuid.UUID
	CreatedBy                     uuid.NullUUID
	CreatedAt                     time.Time
	ModifiedBy                    uuid.NullUUID
	ModifiedAt                    time.Time
	Name                          string
	Description                   string
	Icon                          []byte
	Public                        bool
	PublicSponsoredApiKeyShareID  uuid.NullUUID
	PrivateShareHash              sql.NullString
	PrivateSponsoredApiKeyShareID uuid.NullUUID
	PrivateShareRemaining         sql.NullInt32
	SystemMessageScenario         string
	SystemMessageGameStart        string
	ImageStyle                    string
	Css                           string
	StatusFields                  string
	Theme                         pqtype.NullRawMessage
	FirstMessage                  sql.NullString
	FirstStatus                   sql.NullString
	FirstImage                    []byte
	OriginallyCreatedBy           uuid.NullUUID
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, updateGame,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.Public,
		arg.PublicSponsoredApiKeyShareID,
		arg.PrivateShareHash,
		arg.PrivateSponsoredApiKeyShareID,
		arg.PrivateShareRemaining,
		arg.SystemMessageScenario,
		arg.SystemMessageGameStart,
		arg.ImageStyle,
		arg.Css,
		arg.StatusFields,
		arg.Theme,
		arg.FirstMessage,
		arg.FirstStatus,
		arg.FirstImage,
		arg.OriginallyCreatedBy,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.WorkshopID,
		&i.Public,
		&i.PublicSponsoredApiKeyShareID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyShareID,
		&i.PrivateShareRemaining,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.Theme,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
		&i.OriginallyCreatedBy,
		&i.PlayCount,
		&i.CloneCount,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSession = `-- name: UpdateGameSession :one
UPDATE game_session SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_id = $6,
  user_id = $7,
  api_key_id = $8,
  ai_platform = $9,
  ai_model = $10,
  ai_session = $11,
  image_style = $12,
  language = $13,
  status_fields = $14,
  theme = $15
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at
`

type UpdateGameSessionParams struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.NullUUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	Language     string
	StatusFields string
	Theme        pqtype.NullRawMessage
}

func (q *Queries) UpdateGameSession(ctx context.Context, arg UpdateGameSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, updateGameSession,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.UserID,
		arg.ApiKeyID,
		arg.AiPlatform,
		arg.AiModel,
		arg.AiSession,
		arg.ImageStyle,
		arg.Language,
		arg.StatusFields,
		arg.Theme,
	)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.WorkshopID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.Language,
		&i.StatusFields,
		&i.Theme,
		&i.IsOrganisationUnverified,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionAiSession = `-- name: UpdateGameSessionAiSession :one
UPDATE game_session SET
  ai_session = $2,
  modified_at = now()
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at
`

type UpdateGameSessionAiSessionParams struct {
	ID        uuid.UUID
	AiSession json.RawMessage
}

func (q *Queries) UpdateGameSessionAiSession(ctx context.Context, arg UpdateGameSessionAiSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionAiSession, arg.ID, arg.AiSession)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.WorkshopID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.Language,
		&i.StatusFields,
		&i.Theme,
		&i.IsOrganisationUnverified,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionApiKey = `-- name: UpdateGameSessionApiKey :one
UPDATE game_session SET
  modified_at = now(),
  api_key_id = $2,
  ai_platform = $3,
  ai_model = $4
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, workshop_id, api_key_id, ai_platform, ai_model, ai_session, image_style, language, status_fields, theme, is_organisation_unverified, deleted_at
`

type UpdateGameSessionApiKeyParams struct {
	ID         uuid.UUID
	ApiKeyID   uuid.NullUUID
	AiPlatform string
	AiModel    string
}

func (q *Queries) UpdateGameSessionApiKey(ctx context.Context, arg UpdateGameSessionApiKeyParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionApiKey,
		arg.ID,
		arg.ApiKeyID,
		arg.AiPlatform,
		arg.AiModel,
	)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.WorkshopID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.Language,
		&i.StatusFields,
		&i.Theme,
		&i.IsOrganisationUnverified,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionMessage = `-- name: UpdateGameSessionMessage :one
UPDATE game_session_message SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_session_id = $6,
  type = $7,
  message = $8,
  status = $9,
  image_prompt = $10,
  image = $11,
  has_image = $12,
  has_audio = $13,
  prompt_status_update = $14,
  prompt_response_schema = $15,
  prompt_image_generation = $16,
  prompt_expand_story = $17,
  response_raw = $18,
  token_usage = $19,
  url_analytics = $20
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at
`

type UpdateGameSessionMessageParams struct {
	ID                    uuid.UUID
	CreatedBy             uuid.NullUUID
	CreatedAt             time.Time
	ModifiedBy            uuid.NullUUID
	ModifiedAt            time.Time
	GameSessionID         uuid.UUID
	Type                  string
	Message               string
	Status                sql.NullString
	ImagePrompt           sql.NullString
	Image                 []byte
	HasImage              bool
	HasAudio              bool
	PromptStatusUpdate    sql.NullString
	PromptResponseSchema  sql.NullString
	PromptImageGeneration sql.NullString
	PromptExpandStory     sql.NullString
	ResponseRaw           sql.NullString
	TokenUsage            pqtype.NullRawMessage
	UrlAnalytics          sql.NullString
}

func (q *Queries) UpdateGameSessionMessage(ctx context.Context, arg UpdateGameSessionMessageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionMessage,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameSessionID,
		arg.Type,
		arg.Message,
		arg.Status,
		arg.ImagePrompt,
		arg.Image,
		arg.HasImage,
		arg.HasAudio,
		arg.PromptStatusUpdate,
		arg.PromptResponseSchema,
		arg.PromptImageGeneration,
		arg.PromptExpandStory,
		arg.ResponseRaw,
		arg.TokenUsage,
		arg.UrlAnalytics,
	)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionMessageAudio = `-- name: UpdateGameSessionMessageAudio :one
UPDATE game_session_message SET
  audio = $2,
  modified_at = now()
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at
`

type UpdateGameSessionMessageAudioParams struct {
	ID    uuid.UUID
	Audio []byte
}

func (q *Queries) UpdateGameSessionMessageAudio(ctx context.Context, arg UpdateGameSessionMessageAudioParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionMessageAudio, arg.ID, arg.Audio)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionMessageImage = `-- name: UpdateGameSessionMessageImage :one
UPDATE game_session_message SET
  image = $2,
  modified_at = now()
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image, audio, has_image, has_audio, prompt_status_update, prompt_response_schema, prompt_image_generation, prompt_expand_story, response_raw, token_usage, url_analytics, deleted_at
`

type UpdateGameSessionMessageImageParams struct {
	ID    uuid.UUID
	Image []byte
}

func (q *Queries) UpdateGameSessionMessageImage(ctx context.Context, arg UpdateGameSessionMessageImageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionMessageImage, arg.ID, arg.Image)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
		&i.Audio,
		&i.HasImage,
		&i.HasAudio,
		&i.PromptStatusUpdate,
		&i.PromptResponseSchema,
		&i.PromptImageGeneration,
		&i.PromptExpandStory,
		&i.ResponseRaw,
		&i.TokenUsage,
		&i.UrlAnalytics,
		&i.DeletedAt,
	)
	return i, err
}

const updateGameSessionOrganisationUnverified = `-- name: UpdateGameSessionOrganisationUnverified :exec
UPDATE game_session SET
  modified_at = now(),
  is_organisation_unverified = $2
WHERE id = $1
`

type UpdateGameSessionOrganisationUnverifiedParams struct {
	ID                       uuid.UUID
	IsOrganisationUnverified bool
}

func (q *Queries) UpdateGameSessionOrganisationUnverified(ctx context.Context, arg UpdateGameSessionOrganisationUnverifiedParams) error {
	_, err := q.db.ExecContext(ctx, updateGameSessionOrganisationUnverified, arg.ID, arg.IsOrganisationUnverified)
	return err
}

const updateGameSessionTheme = `-- name: UpdateGameSessionTheme :exec
UPDATE game_session SET
  modified_at = now(),
  theme = $2
WHERE id = $1
`

type UpdateGameSessionThemeParams struct {
	ID    uuid.UUID
	Theme pqtype.NullRawMessage
}

func (q *Queries) UpdateGameSessionTheme(ctx context.Context, arg UpdateGameSessionThemeParams) error {
	_, err := q.db.ExecContext(ctx, updateGameSessionTheme, arg.ID, arg.Theme)
	return err
}

const updateGameTag = `-- name: UpdateGameTag :one
UPDATE game_tag SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_id = $6,
  tag = $7
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, tag
`

type UpdateGameTagParams struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	GameID     uuid.UUID
	Tag        string
}

func (q *Queries) UpdateGameTag(ctx context.Context, arg UpdateGameTagParams) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, updateGameTag,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.Tag,
	)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}
