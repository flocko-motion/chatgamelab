// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createGame = `-- name: CreateGame :one



INSERT INTO game (
  id, created_by,
  created_at, modified_by, modified_at,
  name, description, icon,
  public, public_sponsored_api_key_id,
  private_share_hash, private_sponsored_api_key_id,
  system_message_scenario, system_message_game_start,
  image_style, css, status_fields,
  first_message, first_status, first_image
) VALUES (
  $1, $2,
  $3, $4, $5,
  $6, $7, $8,
  $9, $10,
  $11, $12,
  $13, $14,
  $15, $16, $17,
  $18, $19, $20
)
RETURNING id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image
`

type CreateGameParams struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	Name                     string
	Description              string
	Icon                     []byte
	Public                   bool
	PublicSponsoredApiKeyID  uuid.NullUUID
	PrivateShareHash         sql.NullString
	PrivateSponsoredApiKeyID uuid.NullUUID
	SystemMessageScenario    string
	SystemMessageGameStart   string
	ImageStyle               string
	Css                      string
	StatusFields             string
	FirstMessage             sql.NullString
	FirstStatus              sql.NullString
	FirstImage               []byte
}

// Basic CRUD queries for core entities
// Exactly four per table: create, read by id, update by id, delete by id.
// game -----------------------------------------------------------------
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.Public,
		arg.PublicSponsoredApiKeyID,
		arg.PrivateShareHash,
		arg.PrivateSponsoredApiKeyID,
		arg.SystemMessageScenario,
		arg.SystemMessageGameStart,
		arg.ImageStyle,
		arg.Css,
		arg.StatusFields,
		arg.FirstMessage,
		arg.FirstStatus,
		arg.FirstImage,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Public,
		&i.PublicSponsoredApiKeyID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyID,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
	)
	return i, err
}

const createGameSession = `-- name: CreateGameSession :one

INSERT INTO game_session (
  id, created_by,
  created_at, modified_by, modified_at,
  game_id, user_id, api_key_id,
  ai_platform, ai_model, ai_session,
  image_style, status_fields
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, $6, $7,
  $8, $9, $10,
  $11, $12
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, api_key_id, ai_platform, ai_model, ai_session, image_style, status_fields
`

type CreateGameSessionParams struct {
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
}

// game_session ---------------------------------------------------------
func (q *Queries) CreateGameSession(ctx context.Context, arg CreateGameSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, createGameSession,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.UserID,
		arg.ApiKeyID,
		arg.AiPlatform,
		arg.AiModel,
		arg.AiSession,
		arg.ImageStyle,
		arg.StatusFields,
	)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.StatusFields,
	)
	return i, err
}

const createGameSessionMessage = `-- name: CreateGameSessionMessage :one

INSERT INTO game_session_message (
  id, created_by,
  created_at, modified_by, modified_at,
  game_session_id, seq,
  type, message,
  status, image_prompt, image
) VALUES (
  gen_random_uuid(), $1,
  $2, $3, $4,
  $5, (SELECT COALESCE(MAX(seq), 0) + 1 FROM game_session_message WHERE game_session_id = $5),
  $6, $7,
  $8, $9, $10
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image
`

type CreateGameSessionMessageParams struct {
	CreatedBy     uuid.NullUUID
	CreatedAt     time.Time
	ModifiedBy    uuid.NullUUID
	ModifiedAt    time.Time
	GameSessionID uuid.UUID
	Type          string
	Message       string
	Status        sql.NullString
	ImagePrompt   sql.NullString
	Image         []byte
}

// game_session_message -------------------------------------------------
func (q *Queries) CreateGameSessionMessage(ctx context.Context, arg CreateGameSessionMessageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, createGameSessionMessage,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameSessionID,
		arg.Type,
		arg.Message,
		arg.Status,
		arg.ImagePrompt,
		arg.Image,
	)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
	)
	return i, err
}

const createGameTag = `-- name: CreateGameTag :one

INSERT INTO game_tag (
  id, created_by,
  created_at, modified_by, modified_at,
  game_id, tag
) VALUES (
  $1, $2,
  $3, $4, $5,
  $6, $7
)
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, tag
`

type CreateGameTagParams struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	GameID     uuid.UUID
	Tag        string
}

// game_tag -------------------------------------------------------------
func (q *Queries) CreateGameTag(ctx context.Context, arg CreateGameTagParams) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, createGameTag,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.Tag,
	)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM game WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGame, id)
	return err
}

const deleteGameSession = `-- name: DeleteGameSession :exec
DELETE FROM game_session WHERE id = $1
`

func (q *Queries) DeleteGameSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSession, id)
	return err
}

const deleteGameSessionMessage = `-- name: DeleteGameSessionMessage :exec
DELETE FROM game_session_message WHERE id = $1
`

func (q *Queries) DeleteGameSessionMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessage, id)
	return err
}

const deleteGameSessionMessagesBySessionID = `-- name: DeleteGameSessionMessagesBySessionID :exec
DELETE FROM game_session_message WHERE game_session_id = $1
`

func (q *Queries) DeleteGameSessionMessagesBySessionID(ctx context.Context, gameSessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameSessionMessagesBySessionID, gameSessionID)
	return err
}

const deleteGameTag = `-- name: DeleteGameTag :exec
DELETE FROM game_tag WHERE id = $1
`

func (q *Queries) DeleteGameTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGameTag, id)
	return err
}

const getAllGameSessionMessages = `-- name: GetAllGameSessionMessages :many
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image FROM game_session_message WHERE game_session_id = $1 ORDER BY seq ASC
`

func (q *Queries) GetAllGameSessionMessages(ctx context.Context, gameSessionID uuid.UUID) ([]GameSessionMessage, error) {
	rows, err := q.db.QueryContext(ctx, getAllGameSessionMessages, gameSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameSessionMessage
	for rows.Next() {
		var i GameSessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameSessionID,
			&i.Seq,
			&i.Type,
			&i.Message,
			&i.Status,
			&i.ImagePrompt,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameByID = `-- name: GetGameByID :one
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByID, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Public,
		&i.PublicSponsoredApiKeyID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyID,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
	)
	return i, err
}

const getGameByPrivateShareHash = `-- name: GetGameByPrivateShareHash :one
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE private_share_hash = $1
`

func (q *Queries) GetGameByPrivateShareHash(ctx context.Context, privateShareHash sql.NullString) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByPrivateShareHash, privateShareHash)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Public,
		&i.PublicSponsoredApiKeyID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyID,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
	)
	return i, err
}

const getGameIDsVisibleToUser = `-- name: GetGameIDsVisibleToUser :many
SELECT id FROM game WHERE created_by = $1 OR public = true
`

func (q *Queries) GetGameIDsVisibleToUser(ctx context.Context, createdBy uuid.NullUUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getGameIDsVisibleToUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionByID = `-- name: GetGameSessionByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_id, user_id, api_key_id, ai_platform, ai_model, ai_session, image_style, status_fields FROM game_session WHERE id = $1
`

func (q *Queries) GetGameSessionByID(ctx context.Context, id uuid.UUID) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, getGameSessionByID, id)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.StatusFields,
	)
	return i, err
}

const getGameSessionMessageByID = `-- name: GetGameSessionMessageByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image FROM game_session_message WHERE id = $1
`

func (q *Queries) GetGameSessionMessageByID(ctx context.Context, id uuid.UUID) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, getGameSessionMessageByID, id)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
	)
	return i, err
}

const getGameSessionsByGameID = `-- name: GetGameSessionsByGameID :many
SELECT id, created_by, created_at, modified_by, modified_at, game_id, user_id, api_key_id, ai_platform, ai_model, ai_session, image_style, status_fields FROM game_session WHERE game_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetGameSessionsByGameID(ctx context.Context, gameID uuid.UUID) ([]GameSession, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameSession
	for rows.Next() {
		var i GameSession
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserID = `-- name: GetGameSessionsByUserID :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 
ORDER BY gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) GetGameSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDRow
	for rows.Next() {
		var i GetGameSessionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserIDSortByGame = `-- name: GetGameSessionsByUserIDSortByGame :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 
ORDER BY LOWER(g.name) ASC, gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDSortByGameRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) GetGameSessionsByUserIDSortByGame(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDSortByGameRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserIDSortByGame, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDSortByGameRow
	for rows.Next() {
		var i GetGameSessionsByUserIDSortByGameRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameSessionsByUserIDSortByModel = `-- name: GetGameSessionsByUserIDSortByModel :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 
ORDER BY gs.ai_model ASC, gs.modified_at DESC
LIMIT 20
`

type GetGameSessionsByUserIDSortByModelRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) GetGameSessionsByUserIDSortByModel(ctx context.Context, userID uuid.UUID) ([]GetGameSessionsByUserIDSortByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getGameSessionsByUserIDSortByModel, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameSessionsByUserIDSortByModelRow
	for rows.Next() {
		var i GetGameSessionsByUserIDSortByModelRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameTagByID = `-- name: GetGameTagByID :one
SELECT id, created_by, created_at, modified_by, modified_at, game_id, tag FROM game_tag WHERE id = $1
`

func (q *Queries) GetGameTagByID(ctx context.Context, id uuid.UUID) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, getGameTagByID, id)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}

const getGameTagsByGameID = `-- name: GetGameTagsByGameID :many
SELECT id, created_by, created_at, modified_by, modified_at, game_id, tag FROM game_tag WHERE game_id = $1
`

func (q *Queries) GetGameTagsByGameID(ctx context.Context, gameID uuid.UUID) ([]GameTag, error) {
	rows, err := q.db.QueryContext(ctx, getGameTagsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameTag
	for rows.Next() {
		var i GameTag
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUser = `-- name: GetGamesVisibleToUser :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY created_at DESC
`

func (q *Queries) GetGamesVisibleToUser(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByCreatedAt = `-- name: GetGamesVisibleToUserSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY created_at ASC
`

func (q *Queries) GetGamesVisibleToUserSortedByCreatedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByCreatedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByModifiedAt = `-- name: GetGamesVisibleToUserSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY modified_at DESC
`

func (q *Queries) GetGamesVisibleToUserSortedByModifiedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByModifiedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByModifiedAtAsc = `-- name: GetGamesVisibleToUserSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY modified_at ASC
`

func (q *Queries) GetGamesVisibleToUserSortedByModifiedAtAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByModifiedAtAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByName = `-- name: GetGamesVisibleToUserSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY LOWER(name) ASC
`

func (q *Queries) GetGamesVisibleToUserSortedByName(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByName, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesVisibleToUserSortedByNameDesc = `-- name: GetGamesVisibleToUserSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 OR public = true ORDER BY LOWER(name) DESC
`

func (q *Queries) GetGamesVisibleToUserSortedByNameDesc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getGamesVisibleToUserSortedByNameDesc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGameSessionMessage = `-- name: GetLatestGameSessionMessage :one
SELECT id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image FROM game_session_message WHERE game_session_id = $1 ORDER BY seq DESC LIMIT 1
`

func (q *Queries) GetLatestGameSessionMessage(ctx context.Context, gameSessionID uuid.UUID) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, getLatestGameSessionMessage, gameSessionID)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
	)
	return i, err
}

const getOwnGames = `-- name: GetOwnGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY created_at DESC
`

// Own games (created by user) queries
func (q *Queries) GetOwnGames(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGames, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByCreatedAt = `-- name: GetOwnGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY created_at ASC
`

func (q *Queries) GetOwnGamesSortedByCreatedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByCreatedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByModifiedAt = `-- name: GetOwnGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY modified_at DESC
`

func (q *Queries) GetOwnGamesSortedByModifiedAt(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByModifiedAt, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByModifiedAtAsc = `-- name: GetOwnGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY modified_at ASC
`

func (q *Queries) GetOwnGamesSortedByModifiedAtAsc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByModifiedAtAsc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByName = `-- name: GetOwnGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY LOWER(name) ASC
`

func (q *Queries) GetOwnGamesSortedByName(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByName, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnGamesSortedByNameDesc = `-- name: GetOwnGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 ORDER BY LOWER(name) DESC
`

func (q *Queries) GetOwnGamesSortedByNameDesc(ctx context.Context, createdBy uuid.NullUUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getOwnGamesSortedByNameDesc, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGames = `-- name: GetPublicGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY created_at DESC
`

func (q *Queries) GetPublicGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByCreatedAt = `-- name: GetPublicGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY created_at ASC
`

func (q *Queries) GetPublicGamesSortedByCreatedAt(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByModifiedAt = `-- name: GetPublicGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY modified_at DESC
`

func (q *Queries) GetPublicGamesSortedByModifiedAt(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByModifiedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByModifiedAtAsc = `-- name: GetPublicGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY modified_at ASC
`

func (q *Queries) GetPublicGamesSortedByModifiedAtAsc(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByModifiedAtAsc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByName = `-- name: GetPublicGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY LOWER(name) ASC
`

func (q *Queries) GetPublicGamesSortedByName(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicGamesSortedByNameDesc = `-- name: GetPublicGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true ORDER BY LOWER(name) DESC
`

func (q *Queries) GetPublicGamesSortedByNameDesc(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getPublicGamesSortedByNameDesc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGameSessionsByUserID = `-- name: SearchGameSessionsByUserID :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) SearchGameSessionsByUserID(ctx context.Context, arg SearchGameSessionsByUserIDParams) ([]SearchGameSessionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserID, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGameSessionsByUserIDSortByGame = `-- name: SearchGameSessionsByUserIDSortByGame :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY LOWER(g.name) ASC, gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDSortByGameParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDSortByGameRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) SearchGameSessionsByUserIDSortByGame(ctx context.Context, arg SearchGameSessionsByUserIDSortByGameParams) ([]SearchGameSessionsByUserIDSortByGameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserIDSortByGame, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDSortByGameRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDSortByGameRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGameSessionsByUserIDSortByModel = `-- name: SearchGameSessionsByUserIDSortByModel :many
SELECT 
  gs.id, gs.created_by, gs.created_at, gs.modified_by, gs.modified_at, gs.game_id, gs.user_id, gs.api_key_id, gs.ai_platform, gs.ai_model, gs.ai_session, gs.image_style, gs.status_fields,
  g.name as game_name
FROM game_session gs
JOIN game g ON gs.game_id = g.id
WHERE gs.user_id = $1 AND LOWER(g.name) LIKE LOWER('%' || $2 || '%')
ORDER BY gs.ai_model ASC, gs.modified_at DESC
LIMIT 20
`

type SearchGameSessionsByUserIDSortByModelParams struct {
	UserID  uuid.UUID
	Column2 sql.NullString
}

type SearchGameSessionsByUserIDSortByModelRow struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
	GameName     string
}

func (q *Queries) SearchGameSessionsByUserIDSortByModel(ctx context.Context, arg SearchGameSessionsByUserIDSortByModelParams) ([]SearchGameSessionsByUserIDSortByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, searchGameSessionsByUserIDSortByModel, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGameSessionsByUserIDSortByModelRow
	for rows.Next() {
		var i SearchGameSessionsByUserIDSortByModelRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.GameID,
			&i.UserID,
			&i.ApiKeyID,
			&i.AiPlatform,
			&i.AiModel,
			&i.AiSession,
			&i.ImageStyle,
			&i.StatusFields,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUser = `-- name: SearchGamesVisibleToUser :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at DESC
`

type SearchGamesVisibleToUserParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUser(ctx context.Context, arg SearchGamesVisibleToUserParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUser, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByCreatedAt = `-- name: SearchGamesVisibleToUserSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at ASC
`

type SearchGamesVisibleToUserSortedByCreatedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByCreatedAt(ctx context.Context, arg SearchGamesVisibleToUserSortedByCreatedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByCreatedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByModifiedAt = `-- name: SearchGamesVisibleToUserSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at DESC
`

type SearchGamesVisibleToUserSortedByModifiedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByModifiedAt(ctx context.Context, arg SearchGamesVisibleToUserSortedByModifiedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByModifiedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByModifiedAtAsc = `-- name: SearchGamesVisibleToUserSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at ASC
`

type SearchGamesVisibleToUserSortedByModifiedAtAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByModifiedAtAsc(ctx context.Context, arg SearchGamesVisibleToUserSortedByModifiedAtAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByModifiedAtAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByName = `-- name: SearchGamesVisibleToUserSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) ASC
`

type SearchGamesVisibleToUserSortedByNameParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByName(ctx context.Context, arg SearchGamesVisibleToUserSortedByNameParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByName, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGamesVisibleToUserSortedByNameDesc = `-- name: SearchGamesVisibleToUserSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE (created_by = $1 OR public = true) AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) DESC
`

type SearchGamesVisibleToUserSortedByNameDescParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchGamesVisibleToUserSortedByNameDesc(ctx context.Context, arg SearchGamesVisibleToUserSortedByNameDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchGamesVisibleToUserSortedByNameDesc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGames = `-- name: SearchOwnGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at DESC
`

type SearchOwnGamesParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGames(ctx context.Context, arg SearchOwnGamesParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGames, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByCreatedAt = `-- name: SearchOwnGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY created_at ASC
`

type SearchOwnGamesSortedByCreatedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByCreatedAt(ctx context.Context, arg SearchOwnGamesSortedByCreatedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByCreatedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByModifiedAt = `-- name: SearchOwnGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at DESC
`

type SearchOwnGamesSortedByModifiedAtParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByModifiedAt(ctx context.Context, arg SearchOwnGamesSortedByModifiedAtParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByModifiedAt, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByModifiedAtAsc = `-- name: SearchOwnGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY modified_at ASC
`

type SearchOwnGamesSortedByModifiedAtAscParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByModifiedAtAsc(ctx context.Context, arg SearchOwnGamesSortedByModifiedAtAscParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByModifiedAtAsc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByName = `-- name: SearchOwnGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) ASC
`

type SearchOwnGamesSortedByNameParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByName(ctx context.Context, arg SearchOwnGamesSortedByNameParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByName, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOwnGamesSortedByNameDesc = `-- name: SearchOwnGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE created_by = $1 AND LOWER(name) LIKE LOWER('%' || $2 || '%') ORDER BY LOWER(name) DESC
`

type SearchOwnGamesSortedByNameDescParams struct {
	CreatedBy uuid.NullUUID
	Column2   sql.NullString
}

func (q *Queries) SearchOwnGamesSortedByNameDesc(ctx context.Context, arg SearchOwnGamesSortedByNameDescParams) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchOwnGamesSortedByNameDesc, arg.CreatedBy, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGames = `-- name: SearchPublicGames :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY created_at DESC
`

func (q *Queries) SearchPublicGames(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByCreatedAt = `-- name: SearchPublicGamesSortedByCreatedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY created_at ASC
`

func (q *Queries) SearchPublicGamesSortedByCreatedAt(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByCreatedAt, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByModifiedAt = `-- name: SearchPublicGamesSortedByModifiedAt :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY modified_at DESC
`

func (q *Queries) SearchPublicGamesSortedByModifiedAt(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByModifiedAt, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByModifiedAtAsc = `-- name: SearchPublicGamesSortedByModifiedAtAsc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY modified_at ASC
`

func (q *Queries) SearchPublicGamesSortedByModifiedAtAsc(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByModifiedAtAsc, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByName = `-- name: SearchPublicGamesSortedByName :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY LOWER(name) ASC
`

func (q *Queries) SearchPublicGamesSortedByName(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublicGamesSortedByNameDesc = `-- name: SearchPublicGamesSortedByNameDesc :many
SELECT id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image FROM game WHERE public = true AND LOWER(name) LIKE LOWER('%' || $1 || '%') ORDER BY LOWER(name) DESC
`

func (q *Queries) SearchPublicGamesSortedByNameDesc(ctx context.Context, dollar_1 sql.NullString) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, searchPublicGamesSortedByNameDesc, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Public,
			&i.PublicSponsoredApiKeyID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGame = `-- name: UpdateGame :one
UPDATE game SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  name = $6,
  description = $7,
  icon = $8,
  public = $9,
  public_sponsored_api_key_id = $10,
  private_share_hash = $11,
  private_sponsored_api_key_id = $12,
  system_message_scenario = $13,
  system_message_game_start = $14,
  image_style = $15,
  css = $16,
  status_fields = $17,
  first_message = $18,
  first_status = $19,
  first_image = $20
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, name, description, icon, public, public_sponsored_api_key_id, private_share_hash, private_sponsored_api_key_id, system_message_scenario, system_message_game_start, image_style, css, status_fields, first_message, first_status, first_image
`

type UpdateGameParams struct {
	ID                       uuid.UUID
	CreatedBy                uuid.NullUUID
	CreatedAt                time.Time
	ModifiedBy               uuid.NullUUID
	ModifiedAt               time.Time
	Name                     string
	Description              string
	Icon                     []byte
	Public                   bool
	PublicSponsoredApiKeyID  uuid.NullUUID
	PrivateShareHash         sql.NullString
	PrivateSponsoredApiKeyID uuid.NullUUID
	SystemMessageScenario    string
	SystemMessageGameStart   string
	ImageStyle               string
	Css                      string
	StatusFields             string
	FirstMessage             sql.NullString
	FirstStatus              sql.NullString
	FirstImage               []byte
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, updateGame,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.Public,
		arg.PublicSponsoredApiKeyID,
		arg.PrivateShareHash,
		arg.PrivateSponsoredApiKeyID,
		arg.SystemMessageScenario,
		arg.SystemMessageGameStart,
		arg.ImageStyle,
		arg.Css,
		arg.StatusFields,
		arg.FirstMessage,
		arg.FirstStatus,
		arg.FirstImage,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Public,
		&i.PublicSponsoredApiKeyID,
		&i.PrivateShareHash,
		&i.PrivateSponsoredApiKeyID,
		&i.SystemMessageScenario,
		&i.SystemMessageGameStart,
		&i.ImageStyle,
		&i.Css,
		&i.StatusFields,
		&i.FirstMessage,
		&i.FirstStatus,
		&i.FirstImage,
	)
	return i, err
}

const updateGameSession = `-- name: UpdateGameSession :one
UPDATE game_session SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_id = $6,
  user_id = $7,
  api_key_id = $8,
  ai_platform = $9,
  ai_model = $10,
  ai_session = $11,
  image_style = $12,
  status_fields = $13
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, api_key_id, ai_platform, ai_model, ai_session, image_style, status_fields
`

type UpdateGameSessionParams struct {
	ID           uuid.UUID
	CreatedBy    uuid.NullUUID
	CreatedAt    time.Time
	ModifiedBy   uuid.NullUUID
	ModifiedAt   time.Time
	GameID       uuid.UUID
	UserID       uuid.UUID
	ApiKeyID     uuid.UUID
	AiPlatform   string
	AiModel      string
	AiSession    json.RawMessage
	ImageStyle   string
	StatusFields string
}

func (q *Queries) UpdateGameSession(ctx context.Context, arg UpdateGameSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, updateGameSession,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.UserID,
		arg.ApiKeyID,
		arg.AiPlatform,
		arg.AiModel,
		arg.AiSession,
		arg.ImageStyle,
		arg.StatusFields,
	)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.StatusFields,
	)
	return i, err
}

const updateGameSessionAiSession = `-- name: UpdateGameSessionAiSession :one
UPDATE game_session SET
  ai_session = $2,
  modified_at = now()
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, user_id, api_key_id, ai_platform, ai_model, ai_session, image_style, status_fields
`

type UpdateGameSessionAiSessionParams struct {
	ID        uuid.UUID
	AiSession json.RawMessage
}

func (q *Queries) UpdateGameSessionAiSession(ctx context.Context, arg UpdateGameSessionAiSessionParams) (GameSession, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionAiSession, arg.ID, arg.AiSession)
	var i GameSession
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.UserID,
		&i.ApiKeyID,
		&i.AiPlatform,
		&i.AiModel,
		&i.AiSession,
		&i.ImageStyle,
		&i.StatusFields,
	)
	return i, err
}

const updateGameSessionMessage = `-- name: UpdateGameSessionMessage :one
UPDATE game_session_message SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_session_id = $6,
  type = $7,
  message = $8,
  status = $9,
  image_prompt = $10,
  image = $11
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image
`

type UpdateGameSessionMessageParams struct {
	ID            uuid.UUID
	CreatedBy     uuid.NullUUID
	CreatedAt     time.Time
	ModifiedBy    uuid.NullUUID
	ModifiedAt    time.Time
	GameSessionID uuid.UUID
	Type          string
	Message       string
	Status        sql.NullString
	ImagePrompt   sql.NullString
	Image         []byte
}

func (q *Queries) UpdateGameSessionMessage(ctx context.Context, arg UpdateGameSessionMessageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionMessage,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameSessionID,
		arg.Type,
		arg.Message,
		arg.Status,
		arg.ImagePrompt,
		arg.Image,
	)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
	)
	return i, err
}

const updateGameSessionMessageImage = `-- name: UpdateGameSessionMessageImage :one
UPDATE game_session_message SET
  image = $2,
  modified_at = now()
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_session_id, seq, type, message, status, image_prompt, image
`

type UpdateGameSessionMessageImageParams struct {
	ID    uuid.UUID
	Image []byte
}

func (q *Queries) UpdateGameSessionMessageImage(ctx context.Context, arg UpdateGameSessionMessageImageParams) (GameSessionMessage, error) {
	row := q.db.QueryRowContext(ctx, updateGameSessionMessageImage, arg.ID, arg.Image)
	var i GameSessionMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameSessionID,
		&i.Seq,
		&i.Type,
		&i.Message,
		&i.Status,
		&i.ImagePrompt,
		&i.Image,
	)
	return i, err
}

const updateGameTag = `-- name: UpdateGameTag :one
UPDATE game_tag SET
  created_by = $2,
  created_at = $3,
  modified_by = $4,
  modified_at = $5,
  game_id = $6,
  tag = $7
WHERE id = $1
RETURNING id, created_by, created_at, modified_by, modified_at, game_id, tag
`

type UpdateGameTagParams struct {
	ID         uuid.UUID
	CreatedBy  uuid.NullUUID
	CreatedAt  time.Time
	ModifiedBy uuid.NullUUID
	ModifiedAt time.Time
	GameID     uuid.UUID
	Tag        string
}

func (q *Queries) UpdateGameTag(ctx context.Context, arg UpdateGameTagParams) (GameTag, error) {
	row := q.db.QueryRowContext(ctx, updateGameTag,
		arg.ID,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.GameID,
		arg.Tag,
	)
	var i GameTag
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.GameID,
		&i.Tag,
	)
	return i, err
}
