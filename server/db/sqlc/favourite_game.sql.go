// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: favourite_game.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const addFavouriteGame = `-- name: AddFavouriteGame :one
INSERT INTO user_favourite_game (
        id,
        created_by,
        created_at,
        modified_by,
        modified_at,
        user_id,
        game_id
    )
VALUES (gen_random_uuid(), $1, now(), $1, now(), $1, $2) ON CONFLICT (user_id, game_id) DO NOTHING
RETURNING id
`

type AddFavouriteGameParams struct {
	CreatedBy uuid.NullUUID
	GameID    uuid.UUID
}

// user_favourite_game -----------------------------------------------------
func (q *Queries) AddFavouriteGame(ctx context.Context, arg AddFavouriteGameParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, addFavouriteGame, arg.CreatedBy, arg.GameID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getFavouriteGamesByUserID = `-- name: GetFavouriteGamesByUserID :many
SELECT g.id, g.created_by, g.created_at, g.modified_by, g.modified_at, g.name, g.description, g.icon, g.workshop_id, g.public, g.public_sponsored_api_key_share_id, g.private_share_hash, g.private_sponsored_api_key_share_id, g.system_message_scenario, g.system_message_game_start, g.image_style, g.css, g.status_fields, g.theme, g.first_message, g.first_status, g.first_image, g.originally_created_by, g.play_count, g.clone_count, g.deleted_at
FROM game g
    JOIN user_favourite_game f ON f.game_id = g.id
WHERE f.user_id = $1
ORDER BY f.created_at DESC
`

func (q *Queries) GetFavouriteGamesByUserID(ctx context.Context, userID uuid.UUID) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getFavouriteGamesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.WorkshopID,
			&i.Public,
			&i.PublicSponsoredApiKeyShareID,
			&i.PrivateShareHash,
			&i.PrivateSponsoredApiKeyShareID,
			&i.SystemMessageScenario,
			&i.SystemMessageGameStart,
			&i.ImageStyle,
			&i.Css,
			&i.StatusFields,
			&i.Theme,
			&i.FirstMessage,
			&i.FirstStatus,
			&i.FirstImage,
			&i.OriginallyCreatedBy,
			&i.PlayCount,
			&i.CloneCount,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFavouriteGame = `-- name: IsFavouriteGame :one
SELECT EXISTS(
        SELECT 1
        FROM user_favourite_game
        WHERE user_id = $1
            AND game_id = $2
    ) AS is_favourite
`

type IsFavouriteGameParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
}

func (q *Queries) IsFavouriteGame(ctx context.Context, arg IsFavouriteGameParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isFavouriteGame, arg.UserID, arg.GameID)
	var is_favourite bool
	err := row.Scan(&is_favourite)
	return is_favourite, err
}

const removeFavouriteGame = `-- name: RemoveFavouriteGame :exec
DELETE FROM user_favourite_game
WHERE user_id = $1
    AND game_id = $2
`

type RemoveFavouriteGameParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
}

func (q *Queries) RemoveFavouriteGame(ctx context.Context, arg RemoveFavouriteGameParams) error {
	_, err := q.db.ExecContext(ctx, removeFavouriteGame, arg.UserID, arg.GameID)
	return err
}
