// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_key.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createApiKeyShare = `-- name: CreateApiKeyShare :one

INSERT INTO api_key_share (
  id, created_by, created_at, modified_by, modified_at,
  api_key_id, user_id, workshop_id, institution_id, allow_public_sponsored_plays
) VALUES (
  gen_random_uuid(), $1, $2, $3, $4,
  $5, $6, $7, $8, $9
)
RETURNING id, created_by, created_at, modified_by, modified_at, api_key_id, user_id, workshop_id, institution_id, allow_public_sponsored_plays
`

type CreateApiKeyShareParams struct {
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	AllowPublicSponsoredPlays bool
}

// api_key_share -------------------------------------------------------
func (q *Queries) CreateApiKeyShare(ctx context.Context, arg CreateApiKeyShareParams) (ApiKeyShare, error) {
	row := q.db.QueryRowContext(ctx, createApiKeyShare,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.ApiKeyID,
		arg.UserID,
		arg.WorkshopID,
		arg.InstitutionID,
		arg.AllowPublicSponsoredPlays,
	)
	var i ApiKeyShare
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.ApiKeyID,
		&i.UserID,
		&i.WorkshopID,
		&i.InstitutionID,
		&i.AllowPublicSponsoredPlays,
	)
	return i, err
}

const deleteApiKeyShare = `-- name: DeleteApiKeyShare :exec
DELETE FROM api_key_share WHERE id = $1
`

func (q *Queries) DeleteApiKeyShare(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeyShare, id)
	return err
}

const deleteApiKeySharesByApiKeyID = `-- name: DeleteApiKeySharesByApiKeyID :exec
DELETE FROM api_key_share WHERE api_key_id = $1
`

func (q *Queries) DeleteApiKeySharesByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeySharesByApiKeyID, apiKeyID)
	return err
}

const getApiKeyShareByID = `-- name: GetApiKeyShareByID :one
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.allow_public_sponsored_plays,
  k.id AS key_id,
  k.user_id AS key_owner_id,
  k.name AS key_name,
  k.platform AS key_platform,
  k.key AS key_key,
  o.name AS key_owner_name
FROM api_key_share s
JOIN api_key k ON k.id = s.api_key_id
JOIN app_user o ON o.id = k.user_id
WHERE s.id = $1
`

type GetApiKeyShareByIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	AllowPublicSponsoredPlays bool
	KeyID                     uuid.UUID
	KeyOwnerID                uuid.UUID
	KeyName                   string
	KeyPlatform               string
	KeyKey                    string
	KeyOwnerName              string
}

func (q *Queries) GetApiKeyShareByID(ctx context.Context, id uuid.UUID) (GetApiKeyShareByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyShareByID, id)
	var i GetApiKeyShareByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.ApiKeyID,
		&i.UserID,
		&i.WorkshopID,
		&i.InstitutionID,
		&i.AllowPublicSponsoredPlays,
		&i.KeyID,
		&i.KeyOwnerID,
		&i.KeyName,
		&i.KeyPlatform,
		&i.KeyKey,
		&i.KeyOwnerName,
	)
	return i, err
}

const getApiKeySharesByApiKeyID = `-- name: GetApiKeySharesByApiKeyID :many
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.allow_public_sponsored_plays,
  u.name AS user_name,
  w.name AS workshop_name,
  i.name AS institution_name
FROM api_key_share s
LEFT JOIN app_user u ON u.id = s.user_id
LEFT JOIN workshop w ON w.id = s.workshop_id
LEFT JOIN institution i ON i.id = s.institution_id
WHERE s.api_key_id = $1
`

type GetApiKeySharesByApiKeyIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	AllowPublicSponsoredPlays bool
	UserName                  sql.NullString
	WorkshopName              sql.NullString
	InstitutionName           sql.NullString
}

func (q *Queries) GetApiKeySharesByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) ([]GetApiKeySharesByApiKeyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeySharesByApiKeyID, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeySharesByApiKeyIDRow
	for rows.Next() {
		var i GetApiKeySharesByApiKeyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.ApiKeyID,
			&i.UserID,
			&i.WorkshopID,
			&i.InstitutionID,
			&i.AllowPublicSponsoredPlays,
			&i.UserName,
			&i.WorkshopName,
			&i.InstitutionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeySharesByUserID = `-- name: GetApiKeySharesByUserID :many
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.allow_public_sponsored_plays,
  k.name AS api_key_name,
  k.platform AS api_key_platform,
  k.key AS api_key_key,
  k.user_id AS owner_id,
  owner.name AS owner_name
FROM api_key_share s
JOIN api_key k ON k.id = s.api_key_id
JOIN app_user owner ON owner.id = k.user_id
WHERE s.user_id = $1
`

type GetApiKeySharesByUserIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	AllowPublicSponsoredPlays bool
	ApiKeyName                string
	ApiKeyPlatform            string
	ApiKeyKey                 string
	OwnerID                   uuid.UUID
	OwnerName                 string
}

func (q *Queries) GetApiKeySharesByUserID(ctx context.Context, userID uuid.NullUUID) ([]GetApiKeySharesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeySharesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeySharesByUserIDRow
	for rows.Next() {
		var i GetApiKeySharesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.ApiKeyID,
			&i.UserID,
			&i.WorkshopID,
			&i.InstitutionID,
			&i.AllowPublicSponsoredPlays,
			&i.ApiKeyName,
			&i.ApiKeyPlatform,
			&i.ApiKeyKey,
			&i.OwnerID,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
