// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_key.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const clearGamePrivateShare = `-- name: ClearGamePrivateShare :exec
UPDATE game
SET private_share_hash = NULL,
    private_sponsored_api_key_share_id = NULL,
    private_share_remaining = NULL,
    modified_at = now()
WHERE id = $1
`

// Clear all private share fields on a game (used when revoking via API key deletion)
func (q *Queries) ClearGamePrivateShare(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearGamePrivateShare, id)
	return err
}

const clearGamePublicSponsor = `-- name: ClearGamePublicSponsor :exec
UPDATE game
SET public_sponsored_api_key_share_id = NULL, modified_at = now()
WHERE id = $1
`

func (q *Queries) ClearGamePublicSponsor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearGamePublicSponsor, id)
	return err
}

const clearGameSponsoredApiKeyByApiKeyID = `-- name: ClearGameSponsoredApiKeyByApiKeyID :exec
UPDATE game g
SET
  public_sponsored_api_key_share_id = CASE WHEN g.public_sponsored_api_key_share_id IN (SELECT s.id FROM api_key_share s WHERE s.api_key_id = $1) THEN NULL ELSE g.public_sponsored_api_key_share_id END,
  private_sponsored_api_key_share_id = CASE WHEN g.private_sponsored_api_key_share_id IN (SELECT s.id FROM api_key_share s WHERE s.api_key_id = $1) THEN NULL ELSE g.private_sponsored_api_key_share_id END,
  modified_at = now()
WHERE g.public_sponsored_api_key_share_id IN (SELECT s.id FROM api_key_share s WHERE s.api_key_id = $1)
   OR g.private_sponsored_api_key_share_id IN (SELECT s.id FROM api_key_share s WHERE s.api_key_id = $1)
`

// Clear game sponsoring when an API key is deleted (find shares for that key)
func (q *Queries) ClearGameSponsoredApiKeyByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearGameSponsoredApiKeyByApiKeyID, apiKeyID)
	return err
}

const clearGameSponsoredApiKeyByShareID = `-- name: ClearGameSponsoredApiKeyByShareID :exec
UPDATE game
SET
  public_sponsored_api_key_share_id = CASE WHEN public_sponsored_api_key_share_id = $1 THEN NULL ELSE public_sponsored_api_key_share_id END,
  private_sponsored_api_key_share_id = CASE WHEN private_sponsored_api_key_share_id = $1 THEN NULL ELSE private_sponsored_api_key_share_id END,
  modified_at = now()
WHERE public_sponsored_api_key_share_id = $1 OR private_sponsored_api_key_share_id = $1
`

// Clear game sponsoring when an API key share is deleted
func (q *Queries) ClearGameSponsoredApiKeyByShareID(ctx context.Context, publicSponsoredApiKeyShareID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, clearGameSponsoredApiKeyByShareID, publicSponsoredApiKeyShareID)
	return err
}

const clearSessionApiKeyID = `-- name: ClearSessionApiKeyID :exec
UPDATE game_session SET api_key_id = NULL, modified_at = now() WHERE api_key_id = $1
`

func (q *Queries) ClearSessionApiKeyID(ctx context.Context, apiKeyID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, clearSessionApiKeyID, apiKeyID)
	return err
}

const clearUserDefaultApiKeyShareByApiKeyID = `-- name: ClearUserDefaultApiKeyShareByApiKeyID :exec
UPDATE app_user
SET default_api_key_share_id = NULL, modified_at = now()
WHERE default_api_key_share_id IN (
  SELECT id FROM api_key_share WHERE api_key_id = $1
)
`

func (q *Queries) ClearUserDefaultApiKeyShareByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearUserDefaultApiKeyShareByApiKeyID, apiKeyID)
	return err
}

const createApiKeyShare = `-- name: CreateApiKeyShare :one

INSERT INTO api_key_share (
  id, created_by, created_at, modified_by, modified_at,
  api_key_id, user_id, workshop_id, institution_id, game_id, allow_public_game_sponsoring
) VALUES (
  gen_random_uuid(), $1, $2, $3, $4,
  $5, $6, $7, $8, $9, $10
)
RETURNING id, created_by, created_at, modified_by, modified_at, api_key_id, user_id, workshop_id, institution_id, game_id, allow_public_game_sponsoring
`

type CreateApiKeyShareParams struct {
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	GameID                    uuid.NullUUID
	AllowPublicGameSponsoring bool
}

// api_key_share -------------------------------------------------------
func (q *Queries) CreateApiKeyShare(ctx context.Context, arg CreateApiKeyShareParams) (ApiKeyShare, error) {
	row := q.db.QueryRowContext(ctx, createApiKeyShare,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.ModifiedBy,
		arg.ModifiedAt,
		arg.ApiKeyID,
		arg.UserID,
		arg.WorkshopID,
		arg.InstitutionID,
		arg.GameID,
		arg.AllowPublicGameSponsoring,
	)
	var i ApiKeyShare
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.ApiKeyID,
		&i.UserID,
		&i.WorkshopID,
		&i.InstitutionID,
		&i.GameID,
		&i.AllowPublicGameSponsoring,
	)
	return i, err
}

const deleteApiKeyShare = `-- name: DeleteApiKeyShare :exec
DELETE FROM api_key_share WHERE id = $1
`

func (q *Queries) DeleteApiKeyShare(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeyShare, id)
	return err
}

const deleteApiKeySharesByApiKeyID = `-- name: DeleteApiKeySharesByApiKeyID :exec
DELETE FROM api_key_share WHERE api_key_id = $1
`

func (q *Queries) DeleteApiKeySharesByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeySharesByApiKeyID, apiKeyID)
	return err
}

const deleteApiKeySharesByGameID = `-- name: DeleteApiKeySharesByGameID :exec
DELETE FROM api_key_share WHERE game_id = $1
`

func (q *Queries) DeleteApiKeySharesByGameID(ctx context.Context, gameID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeySharesByGameID, gameID)
	return err
}

const deleteApiKeySharesByOwnerForInstitution = `-- name: DeleteApiKeySharesByOwnerForInstitution :exec
DELETE FROM api_key_share s
WHERE s.api_key_id IN (SELECT k.id FROM api_key k WHERE k.user_id = $1)
  AND s.institution_id = $2
`

type DeleteApiKeySharesByOwnerForInstitutionParams struct {
	UserID        uuid.UUID
	InstitutionID uuid.NullUUID
}

// Delete all API key shares owned by a user that target a specific institution
func (q *Queries) DeleteApiKeySharesByOwnerForInstitution(ctx context.Context, arg DeleteApiKeySharesByOwnerForInstitutionParams) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeySharesByOwnerForInstitution, arg.UserID, arg.InstitutionID)
	return err
}

const deleteApiKeySharesByOwnerForInstitutionWorkshops = `-- name: DeleteApiKeySharesByOwnerForInstitutionWorkshops :exec
DELETE FROM api_key_share s
WHERE s.api_key_id IN (SELECT k.id FROM api_key k WHERE k.user_id = $1)
  AND s.workshop_id IN (SELECT w.id FROM workshop w WHERE w.institution_id = $2)
`

type DeleteApiKeySharesByOwnerForInstitutionWorkshopsParams struct {
	UserID        uuid.UUID
	InstitutionID uuid.UUID
}

// Delete all API key shares owned by a user that target any workshop in a specific institution
func (q *Queries) DeleteApiKeySharesByOwnerForInstitutionWorkshops(ctx context.Context, arg DeleteApiKeySharesByOwnerForInstitutionWorkshopsParams) error {
	_, err := q.db.ExecContext(ctx, deleteApiKeySharesByOwnerForInstitutionWorkshops, arg.UserID, arg.InstitutionID)
	return err
}

const getApiKeyShareByID = `-- name: GetApiKeyShareByID :one
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.game_id,
  s.allow_public_game_sponsoring,
  k.id AS key_id,
  k.user_id AS key_owner_id,
  k.name AS key_name,
  k.platform AS key_platform,
  k.key AS key_key,
  k.is_default AS key_is_default,
  k.last_usage_success AS key_last_usage_success,
  o.name AS key_owner_name
FROM api_key_share s
JOIN api_key k ON k.id = s.api_key_id
JOIN app_user o ON o.id = k.user_id
WHERE s.id = $1
`

type GetApiKeyShareByIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	GameID                    uuid.NullUUID
	AllowPublicGameSponsoring bool
	KeyID                     uuid.UUID
	KeyOwnerID                uuid.UUID
	KeyName                   string
	KeyPlatform               string
	KeyKey                    string
	KeyIsDefault              bool
	KeyLastUsageSuccess       sql.NullBool
	KeyOwnerName              string
}

func (q *Queries) GetApiKeyShareByID(ctx context.Context, id uuid.UUID) (GetApiKeyShareByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyShareByID, id)
	var i GetApiKeyShareByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ModifiedBy,
		&i.ModifiedAt,
		&i.ApiKeyID,
		&i.UserID,
		&i.WorkshopID,
		&i.InstitutionID,
		&i.GameID,
		&i.AllowPublicGameSponsoring,
		&i.KeyID,
		&i.KeyOwnerID,
		&i.KeyName,
		&i.KeyPlatform,
		&i.KeyKey,
		&i.KeyIsDefault,
		&i.KeyLastUsageSuccess,
		&i.KeyOwnerName,
	)
	return i, err
}

const getApiKeySharesByApiKeyID = `-- name: GetApiKeySharesByApiKeyID :many
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.game_id,
  s.allow_public_game_sponsoring,
  u.name AS user_name,
  w.name AS workshop_name,
  i.name AS institution_name,
  g.name AS game_name
FROM api_key_share s
LEFT JOIN app_user u ON u.id = s.user_id
LEFT JOIN workshop w ON w.id = s.workshop_id
LEFT JOIN institution i ON i.id = s.institution_id
LEFT JOIN game g ON g.id = s.game_id
WHERE s.api_key_id = $1
`

type GetApiKeySharesByApiKeyIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	GameID                    uuid.NullUUID
	AllowPublicGameSponsoring bool
	UserName                  sql.NullString
	WorkshopName              sql.NullString
	InstitutionName           sql.NullString
	GameName                  sql.NullString
}

func (q *Queries) GetApiKeySharesByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) ([]GetApiKeySharesByApiKeyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeySharesByApiKeyID, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeySharesByApiKeyIDRow
	for rows.Next() {
		var i GetApiKeySharesByApiKeyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.ApiKeyID,
			&i.UserID,
			&i.WorkshopID,
			&i.InstitutionID,
			&i.GameID,
			&i.AllowPublicGameSponsoring,
			&i.UserName,
			&i.WorkshopName,
			&i.InstitutionName,
			&i.GameName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeySharesByInstitutionID = `-- name: GetApiKeySharesByInstitutionID :many
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.game_id,
  s.allow_public_game_sponsoring,
  k.name AS api_key_name,
  k.platform AS api_key_platform,
  k.user_id AS owner_id,
  owner.name AS owner_name
FROM api_key_share s
JOIN api_key k ON k.id = s.api_key_id
JOIN app_user owner ON owner.id = k.user_id
WHERE s.institution_id = $1
`

type GetApiKeySharesByInstitutionIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	GameID                    uuid.NullUUID
	AllowPublicGameSponsoring bool
	ApiKeyName                string
	ApiKeyPlatform            string
	OwnerID                   uuid.UUID
	OwnerName                 string
}

func (q *Queries) GetApiKeySharesByInstitutionID(ctx context.Context, institutionID uuid.NullUUID) ([]GetApiKeySharesByInstitutionIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeySharesByInstitutionID, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeySharesByInstitutionIDRow
	for rows.Next() {
		var i GetApiKeySharesByInstitutionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.ApiKeyID,
			&i.UserID,
			&i.WorkshopID,
			&i.InstitutionID,
			&i.GameID,
			&i.AllowPublicGameSponsoring,
			&i.ApiKeyName,
			&i.ApiKeyPlatform,
			&i.OwnerID,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeySharesByUserID = `-- name: GetApiKeySharesByUserID :many
SELECT
  s.id,
  s.created_by,
  s.created_at,
  s.modified_by,
  s.modified_at,
  s.api_key_id,
  s.user_id,
  s.workshop_id,
  s.institution_id,
  s.game_id,
  s.allow_public_game_sponsoring,
  k.name AS api_key_name,
  k.platform AS api_key_platform,
  k.key AS api_key_key,
  k.is_default AS api_key_is_default,
  k.last_usage_success AS api_key_last_usage_success,
  k.user_id AS owner_id,
  owner.name AS owner_name
FROM api_key_share s
JOIN api_key k ON k.id = s.api_key_id
JOIN app_user owner ON owner.id = k.user_id
WHERE s.user_id = $1
`

type GetApiKeySharesByUserIDRow struct {
	ID                        uuid.UUID
	CreatedBy                 uuid.NullUUID
	CreatedAt                 time.Time
	ModifiedBy                uuid.NullUUID
	ModifiedAt                time.Time
	ApiKeyID                  uuid.UUID
	UserID                    uuid.NullUUID
	WorkshopID                uuid.NullUUID
	InstitutionID             uuid.NullUUID
	GameID                    uuid.NullUUID
	AllowPublicGameSponsoring bool
	ApiKeyName                string
	ApiKeyPlatform            string
	ApiKeyKey                 string
	ApiKeyIsDefault           bool
	ApiKeyLastUsageSuccess    sql.NullBool
	OwnerID                   uuid.UUID
	OwnerName                 string
}

func (q *Queries) GetApiKeySharesByUserID(ctx context.Context, userID uuid.NullUUID) ([]GetApiKeySharesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeySharesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeySharesByUserIDRow
	for rows.Next() {
		var i GetApiKeySharesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ModifiedBy,
			&i.ModifiedAt,
			&i.ApiKeyID,
			&i.UserID,
			&i.WorkshopID,
			&i.InstitutionID,
			&i.GameID,
			&i.AllowPublicGameSponsoring,
			&i.ApiKeyName,
			&i.ApiKeyPlatform,
			&i.ApiKeyKey,
			&i.ApiKeyIsDefault,
			&i.ApiKeyLastUsageSuccess,
			&i.OwnerID,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesWithPrivateShareByApiKeyID = `-- name: GetGamesWithPrivateShareByApiKeyID :many
SELECT g.id, g.name, g.private_sponsored_api_key_share_id, g.private_share_remaining
FROM game g
JOIN api_key_share s ON g.private_sponsored_api_key_share_id = s.id
WHERE s.api_key_id = $1
  AND g.deleted_at IS NULL
  AND g.private_share_hash IS NOT NULL
`

type GetGamesWithPrivateShareByApiKeyIDRow struct {
	ID                            uuid.UUID
	Name                          string
	PrivateSponsoredApiKeyShareID uuid.NullUUID
	PrivateShareRemaining         sql.NullInt32
}

// Find games that use a share of this API key for private share sponsoring
func (q *Queries) GetGamesWithPrivateShareByApiKeyID(ctx context.Context, apiKeyID uuid.UUID) ([]GetGamesWithPrivateShareByApiKeyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGamesWithPrivateShareByApiKeyID, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesWithPrivateShareByApiKeyIDRow
	for rows.Next() {
		var i GetGamesWithPrivateShareByApiKeyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PrivateSponsoredApiKeyShareID,
			&i.PrivateShareRemaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkshopIDsByInstitution = `-- name: GetWorkshopIDsByInstitution :many
SELECT id FROM workshop WHERE institution_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetWorkshopIDsByInstitution(ctx context.Context, institutionID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getWorkshopIDsByInstitution, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setGamePublicSponsor = `-- name: SetGamePublicSponsor :exec
UPDATE game
SET public_sponsored_api_key_share_id = $2, modified_at = now()
WHERE id = $1
`

type SetGamePublicSponsorParams struct {
	ID                           uuid.UUID
	PublicSponsoredApiKeyShareID uuid.NullUUID
}

func (q *Queries) SetGamePublicSponsor(ctx context.Context, arg SetGamePublicSponsorParams) error {
	_, err := q.db.ExecContext(ctx, setGamePublicSponsor, arg.ID, arg.PublicSponsoredApiKeyShareID)
	return err
}

const updateApiKeyShareAllowPublicGameSponsoring = `-- name: UpdateApiKeyShareAllowPublicGameSponsoring :exec
UPDATE api_key_share
SET allow_public_game_sponsoring = $2, modified_at = now()
WHERE id = $1
`

type UpdateApiKeyShareAllowPublicGameSponsoringParams struct {
	ID                        uuid.UUID
	AllowPublicGameSponsoring bool
}

func (q *Queries) UpdateApiKeyShareAllowPublicGameSponsoring(ctx context.Context, arg UpdateApiKeyShareAllowPublicGameSponsoringParams) error {
	_, err := q.db.ExecContext(ctx, updateApiKeyShareAllowPublicGameSponsoring, arg.ID, arg.AllowPublicGameSponsoring)
	return err
}
